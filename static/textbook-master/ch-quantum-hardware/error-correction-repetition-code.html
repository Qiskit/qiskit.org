<!DOCTYPE html>
<html lang="en">
  

  <script>
(function () {
  'use strict'
  window.digitalData = {
    page: {
      pageInfo: {
        productTitle: 'IBM Q Experience',
        analytics: {
          category: 'Qiskit.org'
        }
      }
    }
  }
  window._analytics = {
    segment_key: 'ffdYLviQze3kzomaINXNk6NwpY9LlXcw'
  }
}());
</script>
<script async src="https://cloud.ibm.com/analytics/build/bluemix-analytics.min.js"></script>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <title>Introduction to Quantum Error Correction using Repetition Codes</title>
  <meta name="description" content="            Introduction to Quantum Error Correction via the Repetition Code Introduction Quantum computing requires us to encode information in qubits. Most...">

  <link rel="canonical" href="https://community.qiskit.orgtextbook-master/ch-quantum-hardware/error-correction-repetition-code.html">
  <link rel="alternate" type="application/rss+xml" title="Qiskit Textbook" href="https://community.qiskit.orgtextbook-master/feed.xml">

  <meta property="og:url"         content="https://community.qiskit.orgtextbook-master/ch-quantum-hardware/error-correction-repetition-code.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Introduction to Quantum Error Correction using Repetition Codes" />
<meta property="og:description" content="            Introduction to Quantum Error Correction via the Repetition Code Introduction Quantum computing requires us to encode information in qubits. Most..." />
<meta property="og:image"       content="https://community.qiskit.org/textbook-master/images/logo/logo.png" />

<meta name="twitter:card" content="summary">


  <script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage": "https://community.qiskit.orgtextbook-master/ch-quantum-hardware/error-correction-repetition-code.html",
  "headline": "Introduction to Quantum Error Correction using Repetition Codes",
  "datePublished": "2020-01-22T18:29:34+00:00",
  "dateModified": "2020-01-22T18:29:34+00:00",
  "description": "            Introduction to Quantum Error Correction via the Repetition Code Introduction Quantum computing requires us to encode information in qubits. Most...",
  "author": {
    "@type": "Person",
    "name": "The Qiskit Team"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data 100 at UC Berkeley",
    "logo": {
      "@type": "ImageObject",
      "url": "https://community.qiskit.orgtextbook-master",
      "width": 60,
      "height": 60
    }
  },
  "image": {
    "@type": "ImageObject",
    "url": "https://community.qiskit.orgtextbook-master",
    "height": 60,
    "width": 60
  }
}

  </script>
  <link rel="stylesheet" href="/textbook-master/assets/css/styles.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css ">

  <!-- <link rel="manifest" href="/manifest.json"> -->
  <!-- <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#efae0a"> -->
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="theme-color" content="#233947">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="/textbook-master/images/logo/favicon.ico">

  <!-- MathJax Config -->
  <!-- Allow inline math using $ and automatically break long math lines -->
<!-- (mostly) copied from nbconvert configuration -->
<!-- https://github.com/jupyter/nbconvert/blob/master/nbconvert/templates/html/mathjax.tpl -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true },
    }
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML' async></script>

  <!-- DOM updating function -->
  <script>
const runWhenDOMLoaded = cb => {
  if (document.readyState != 'loading') {
    cb()
  } else if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', cb)
  } else {
    document.attachEvent('onreadystatechange', function() {
      if (document.readyState == 'complete') cb()
    })
  }
}

// Helper function to init things quickly
initFunction = function(myfunc) {
  runWhenDOMLoaded(myfunc);
  document.addEventListener('turbolinks:load', myfunc);
};
</script>

  <!-- Define some javascript variables that will be useful in other javascript -->
  <script>
    const site_basename = 'textbook-master';
  </script>

  <!-- Add AnchorJS to let headers be linked -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js" async></script>
  <script>
const initAnchors = () => {
  if (window.anchors === undefined) {
    setTimeout(initAnchors, 250)
    return
  }
  anchors.add("main h1, main h2, main h3, main h4")
}

initFunction(initAnchors);
</script>


  <!-- Include Turbolinks to make page loads fast -->
  <!-- https://github.com/turbolinks/turbolinks -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turbolinks/5.2.0/turbolinks.js" async></script>
  <meta name="turbolinks-cache-control" content="no-cache">

  <!-- Selectors for elements on the page -->
  <script>
/**
 * Select various elements on the page for later use
 */

// IDs we'll attach to cells
const codeCellId = index => `codecell${index}`
const inputCellId = index => `inputcell${index}`

pageElements = {}

// All code cells
findCodeCells = function() {
    var codeCells = document.querySelectorAll('div.c-textbook__content > div.highlighter-rouge > div.highlight > pre, div.input_area pre, div.text_cell_render div.highlight pre')
    pageElements['codeCells'] = codeCells;

    codeCells.forEach((codeCell, index) => {
      const id = codeCellId(index)
      codeCell.setAttribute('id', id)
    })
};

initFunction(findCodeCells);

// All cells in general
findInputCells = function() {
    var inputCells = document.querySelectorAll('div.jb_cell')
    pageElements['inputCells'] = inputCells;

    inputCells.forEach((inputCell, index) => {
        const id = inputCellId(index)
        inputCell.setAttribute('id', id)
    })
};

initFunction(findInputCells);
</script>

  <!-- Load nbinteract for widgets -->
  

  <!-- Load Thebelab for interactive widgets -->
  <!-- Include Thebelab for interactive code if it's enabled -->



  <!-- Load the auto-generating TOC -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js" async></script>
<script>
const initToc = () => {
  if (window.tocbot === undefined) {
    setTimeout(initToc, 250)
    return
  }

  // Check whether we have any sidebar content. If not, then show the sidebar earlier.
  var SIDEBAR_CONTENT_TAGS = ['.tag_full_width', '.tag_popout'];
  var sidebar_content_query = SIDEBAR_CONTENT_TAGS.join(', ')
  if (document.querySelectorAll(sidebar_content_query).length === 0) {
    document.querySelector('nav.onthispage').classList.add('no_sidebar_content')
  }

  // Initialize the TOC bot
  tocbot.init({
    tocSelector: 'nav.onthispage',
    contentSelector: '.c-textbook__content',
    headingSelector: 'h2, h3',
    orderedList: false,
    collapseDepth: 6,
    listClass: 'toc__menu',
    activeListItemClass: "",  // Not using
    activeLinkClass: "", // Not using
  });

}
initFunction(initToc);
</script>


  <!-- Google analytics -->
  <script src="/textbook-master/assets/js/ga.js" async></script>

  <!-- Clipboard copy button -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script>

  <!-- Load custom website scripts -->
  <script src="/textbook-master/assets/js/scripts.js" async></script>

  <!-- Load custom user CSS and JS  -->
  <script src="/textbook-master/assets/custom/custom.js" async></script>
  <link rel="stylesheet" href="/textbook-master/assets/custom/custom.css">

  <!-- Update interact links w/ REST param, is defined in includes so we can use templates -->
  

  <!-- Lunr search code - will only be executed on the /search page -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" async></script>
  <script>var initQuery = function() {
  // See if we have a search box
  var searchInput = document.querySelector('input#lunr_search');
  if (searchInput === null) {
    return;
  }

  // Function to parse our lunr cache
  var idx = lunr(function () {
    this.field('title')
    this.field('excerpt')
    this.field('categories')
    this.field('tags')
    this.ref('id')

    this.pipeline.remove(lunr.trimmer)

    for (var item in store) {
      this.add({
        title: store[item].title,
        excerpt: store[item].excerpt,
        categories: store[item].categories,
        tags: store[item].tags,
        id: item
      })
    }
  });

  // Run search upon keyup
  searchInput.addEventListener('keyup', function () {
    var resultdiv = document.querySelector('#results');
    var query = document.querySelector("input#lunr_search").value.toLowerCase();
    var result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(function (term) {
          q.term(term, { boost: 100 })
          if(query.lastIndexOf(" ") != query.length-1){
            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })
          }
          if (term != ""){
            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })
          }
        })
      });

      // Empty the results div
      while (resultdiv.firstChild) {
        resultdiv.removeChild(resultdiv.firstChild);
      }

    resultdiv.insertAdjacentHTML('afterbegin', '<p class="results__found">'+result.length+' Result(s) found</p>');
    for (var item in result) {
      var ref = result[item].ref;
      if(store[ref].teaser){
        var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<div class="archive__item-teaser">'+
                '<img src="'+store[ref].teaser+'" alt="">'+
              '</div>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      else{
    	  var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      resultdiv.insertAdjacentHTML('beforeend', searchitem);
    }
  });
};

initFunction(initQuery);
</script>

  <!-- Load JS that depends on site variables -->
  <script>
/**
 * Set up copy/paste for code blocks
 */
const clipboardButton = id =>
  `<a id="copy-button-${id}" class="btn copybtn o-tooltip--left" data-tooltip="Copy" data-clipboard-target="#${id}">
    <img src="/textbook-master/assets/images/copy-button.svg" alt="Copy to clipboard">
  </a>`

// Clears selected text since ClipboardJS will select the text when copying
const clearSelection = () => {
  if (window.getSelection) {
    window.getSelection().removeAllRanges()
  } else if (document.selection) {
    document.selection.empty()
  }
}

// Changes tooltip text for two seconds, then changes it back
const temporarilyChangeTooltip = (el, newText) => {
  const oldText = el.getAttribute('data-tooltip')
  el.setAttribute('data-tooltip', newText)
  setTimeout(() => el.setAttribute('data-tooltip', oldText), 2000)
}

const addCopyButtonToCodeCells = () => {
  // If ClipboardJS hasn't loaded, wait a bit and try again. This
  // happens because we load ClipboardJS asynchronously.
  if (window.ClipboardJS === undefined) {
    setTimeout(addCopyButtonToCodeCells, 250)
    return
  }

  pageElements['codeCells'].forEach((codeCell) => {
    const id = codeCell.getAttribute('id')
    if (document.getElementById("copy-button" + id) == null) {
      codeCell.insertAdjacentHTML('afterend', clipboardButton(id));
    }
  })

  const clipboard = new ClipboardJS('.copybtn')
  clipboard.on('success', event => {
    clearSelection()
    temporarilyChangeTooltip(event.trigger, 'Copied!')
  })

  clipboard.on('error', event => {
    temporarilyChangeTooltip(event.trigger, 'Failed to copy')
  })

  // Get rid of clipboard before the next page visit to avoid memory leak
  document.addEventListener('turbolinks:before-visit', () =>
    clipboard.destroy()
  )
}

initFunction(addCopyButtonToCodeCells);
</script>


  <!-- Hide cell code -->
  <script>
    /**
    Add buttons to hide code cells
    */


    var setCodeCellVisibility = function (inputField, kind) {
        // Update the image and class for hidden
        var id = inputField.getAttribute('data-id');
        var codeCell = document.querySelector(`#${id} div.highlight`);

        if (kind === "visible") {
            codeCell.classList.remove('hidden');
            inputField.checked = true;
        } else {
            codeCell.classList.add('hidden');
            inputField.checked = false;
        }
    }

    var toggleCodeCellVisibility = function (event) {
        // The label is clicked, and now we decide what to do based on the input field's clicked status
        if (event.target.tagName === "LABEL") {
            var inputField = event.target.previousElementSibling;
        } else {
            // It is the span inside the target
            var inputField = event.target.parentElement.previousElementSibling;
        }

        if (inputField.checked === true) {
            setCodeCellVisibility(inputField, "visible");
        } else {
            setCodeCellVisibility(inputField, "hidden");
        }
    }


    // Button constructor
    const hideCodeButton = id => `<input class="hidebtn" type="checkbox" id="hidebtn${id}" data-id="${id}"><label title="Toggle cell" for="hidebtn${id}" class="plusminus"><span class="pm_h"></span><span class="pm_v"></span></label>`

    var addHideButton = function () {
        // If a hide button is already added, don't add another
        if (document.querySelector('div.tag_hide_input input') !== null) {
            return;
        }

        // Find the input cells and add a hide button
        pageElements['inputCells'].forEach(function (inputCell) {
            if (!inputCell.classList.contains("tag_hide_input")) {
                // Skip the cell if it doesn't have a hidecode class
                return;
            }

            const id = inputCell.getAttribute('id')

            // Insert the button just inside the end of the next div
            inputCell.querySelector('div.input').insertAdjacentHTML('beforeend', hideCodeButton(id))

            // Set up the visibility toggle
            hideLink = document.querySelector(`#${id} div.inner_cell + input + label`);
            hideLink.addEventListener('click', toggleCodeCellVisibility)
        });
    }


    // Initialize the hide buttos
    var initHiddenCells = function () {
        // Add hide buttons to the cells
        addHideButton();

        // Toggle the code cells that should be hidden
        document.querySelectorAll('div.tag_hide_input input').forEach(function (item) {
            setCodeCellVisibility(item, 'hidden');
            item.checked = true;
        })
    }

    initFunction(initHiddenCells);

</script>

  <!-- Printing the screen -->
  <!-- Include nbinteract for interactive widgets -->
<script src="https://printjs-4de6.kxcdn.com/print.min.js" async></script>
<script>
printContent = () => {
    // MathJax displays a second version of any math for assistive devices etc.
    // This prevents double-rendering in the PDF output.
    var ignoreAssistList = [];
    assistives = document.querySelectorAll('.MathJax_Display span.MJX_Assistive_MathML').forEach((element, index) => {
        var thisId = 'MathJax-assistive-' + index.toString();
        element.setAttribute('id', thisId);
        ignoreAssistList.push(thisId)
    });

    // Print the actual content object
    printJS({
        printable: 'textbook_content',
        type: 'html',
        css: "/textbook-master/assets/css/styles.css",
        scanStyles: false,
        targetStyles: ["*"],
        ignoreElements: ignoreAssistList
    })
};

initPrint = () => {
    document.querySelector('#interact-button-print').addEventListener('click', printContent)
}

initFunction(initPrint)
</script>

</head>

  <body>
    <!-- .js-show-sidebar shows sidebar by default -->
    <div id="js-textbook" class="c-textbook js-show-sidebar">
      



<nav id="js-sidebar" class="c-textbook__sidebar">
  <a href="https://qiskit.org/textbook"><img src="/textbook-master/images/logo/logo.png" class="textbook_logo" id="sidebar-logo" data-turbolinks-permanent/></a>
  <h2 class="c-sidebar__title">Qiskit Textbook</h2>
  <ul class="c-sidebar__chapters">
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/preface.html"
        >
          
          Preface
        </a>

        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/upcoming.html"
        >
          
          Upcoming
        </a>

        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/ch-prerequisites/python-and-jupyter-notebooks.html"
        >
          
            0.
          
          Prerequisites
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-prerequisites/python-and-jupyter-notebooks.html"
                >
                  
                    0.1
                  
                  Python and Jupyter Notebooks
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-prerequisites/qiskit.html"
                >
                  
                    0.2
                  
                  Qiskit
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-prerequisites/linear_algebra.html"
                >
                  
                    0.3
                  
                  Linear Algebra
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/ch-states/introduction.html"
        >
          
            1.
          
          Quantum States and Qubits
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-states/introduction.html"
                >
                  
                    1.1
                  
                  Introduction
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-states/atoms-computation.html"
                >
                  
                    1.2
                  
                  The Atoms of Computation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-states/unique-properties-qubits.html"
                >
                  
                    1.3
                  
                  The Unique Properties of Qubits
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-states/writing-down-qubit-states.html"
                >
                  
                    1.4
                  
                  Writing Down Qubit States
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-states/pauli-matrices-bloch-sphere.html"
                >
                  
                    1.5
                  
                  Pauli Matrices and the Bloch Sphere
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-states/states-many-qubits.html"
                >
                  
                    1.6
                  
                  States for Many Qubits
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/ch-gates/introduction.html"
        >
          
            2.
          
          Single Qubits and Multi-Qubits gates
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-gates/introduction.html"
                >
                  
                    2.1
                  
                  Introduction
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-gates/quantum-gates.html"
                >
                  
                    2.2
                  
                  Quantum Gates
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-gates/fun-matrices.html"
                >
                  
                    2.3
                  
                  Fun with Matrices
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-gates/standard-gate-set.html"
                >
                  
                    2.4
                  
                  The Standard Gate Set
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-gates/proving-universality.html"
                >
                  
                    2.5
                  
                  Proving Universality
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-gates/basic-circuit-identities.html"
                >
                  
                    2.6
                  
                  Basic Circuit Identities
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/ch-ex/ex1.html"
        >
          
          Problems
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-ex/ex1.html"
                >
                  
                  Set 1. Classical Logic Gates with Quantum Circuits
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-ex/ex2.html"
                >
                  
                  Set 2. Basic Synthesis of Single-Qubit Gates
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-ex/ex3.html"
                >
                  
                  Set 3. Building the Best AND Gate
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/ch-algorithms/teleportation.html"
        >
          
            3.
          
          Quantum Algorithms
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-algorithms/teleportation.html"
                >
                  
                    3.1
                  
                  Quantum Teleportation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-algorithms/deutsch-josza.html"
                >
                  
                    3.2
                  
                  Deutsch-Josza Algorithm
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-algorithms/bernstein-vazirani.html"
                >
                  
                    3.3
                  
                  Bernstein-Vazirani Algorithm
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-algorithms/simon.html"
                >
                  
                    3.4
                  
                  Simon's Algorithm
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-algorithms/quantum-fourier-transform.html"
                >
                  
                    3.5
                  
                  Quantum Fourier Transform
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-algorithms/quantum-phase-estimation.html"
                >
                  
                    3.6
                  
                  Quantum Phase Estimation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-algorithms/grover.html"
                >
                  
                    3.7
                  
                  Grover's Algorithm
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/ch-applications/vqe-molecules.html"
        >
          
            4.
          
          Quantum Algorithms for Applications
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-applications/vqe-molecules.html"
                >
                  
                    4.1
                  
                  Simulating Molecules using VQE
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-applications/qaoa.html"
                >
                  
                    4.2
                  
                  Solving combinatorial optimization problems using QAOA
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-applications/satisfiability-grover.html"
                >
                  
                    4.3
                  
                  Solving Satisfiability Problems using Grover's Algorithm
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/ch-quantum-hardware/calibrating-qubits-openpulse.html"
        >
          
            5.
          
          Investigating Quantum Hardware Using Qiskit
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-quantum-hardware/calibrating-qubits-openpulse.html"
                >
                  
                    5.1
                  
                  Calibrating Qubits with OpenPulse
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry c-sidebar__entry--active"
                  href="/textbook-master/ch-quantum-hardware/error-correction-repetition-code.html"
                >
                  
                    5.2
                  
                  Introduction to Quantum Error Correction using Repetition Codes
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-quantum-hardware/measurement-error-mitigation.html"
                >
                  
                    5.3
                  
                  Measurement Error Mitigation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-quantum-hardware/randomized-benchmarking.html"
                >
                  
                    5.4
                  
                  Randomized Benchmarking
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-quantum-hardware/measuring-quantum-volume.html"
                >
                  
                    5.5
                  
                  Measuring Quantum Volume
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook-master/ch-paper-implementations/vqls.html"
        >
          
            6.
          
          Implementations of Recent Quantum Algorithms
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook-master/ch-paper-implementations/vqls.html"
                >
                  
                    6.1
                  
                  Variational Quantum Linear Solver
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
  </ul>
  <p class="sidebar_footer">Powered by <a href="https://github.com/jupyter/jupyter-book">Jupyter Book</a></p>
</nav>

      
      <div class="c-topbar" id="top-navbar">
  <!-- We show the sidebar by default so we use .is-active -->
  <div class="c-topbar__buttons">
    <button
      id="js-sidebar-toggle"
      class="hamburger hamburger--arrowalt is-active"
    >
      <span class="hamburger-box">
        <span class="hamburger-inner"></span>
      </span>
    </button>
    <div class="buttons">
<div class="download-buttons-dropdown">
    <button id="dropdown-button-trigger" class="interact-button"><i class="fa fa-download"></i></button>
    <div class="download-buttons">
        <a href="/textbook-master/content/ch-quantum-hardware/error-correction-repetition-code.ipynb" download>
        <button id="interact-button-download" class="interact-button">ORIG</button>
        </a>
        
        <a id="interact-button-print"><button id="interact-button-download" class="interact-button">PDF</button></a>
    </div>
</div>

  
  
  
  


</div>

  </div>
  <!-- Empty sidebar placeholder that we'll auto-fill with javascript -->
  <aside class="sidebar__right">
    <header><h4 class="nav__title"><i class="fa fa-list"></i>   On this page</h4></header>
    <nav class="onthispage">
    </nav>
  </aside>
  <a href="/textbook-master/search.html" class="topbar-right-button" id="search-button"><i class="fa fa-search"></i></a>
</div>

      <main class="c-textbook__page" tabindex="-1">
        <div class="c-textbook__content" id="textbook_content">
              <main class="jupyter-page">
    <div id="page-info"></div>
    <div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Introduction-to-Quantum-Error-Correction-via-the-Repetition-Code">Introduction to Quantum Error Correction via the Repetition Code<a class="anchor-link" href="#Introduction-to-Quantum-Error-Correction-via-the-Repetition-Code"> </a></h1>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Introduction">Introduction<a class="anchor-link" href="#Introduction"> </a></h2><p>Quantum computing requires us to encode information in qubits. Most quantum algorithms developed over the past few decades have assumed that these qubits are perfect: they can be prepared in any state we desire, and be manipulated with complete precision. Qubits that obey these assumptions are often known as <em>logical qubits</em>.</p>
<p>The last few decades have also seen great advances in finding physical systems that behave as qubits, with better quality qubits being developed all the time. However, the imperfections can never be removed entirely. These qubits will always be much too imprecise to serve directly as logical qubits. Instead, we refer to them as <em>physical qubits</em>.</p>
<p>In the current era of quantum computing, we seek to use physical qubits despite their imperfections, by designing custom algorithms and using error mitigation effects. For the future era of fault-tolerance, however, we must find ways to build logical qubits from physical qubits. This will be done through the process of quantum error correction, in which logical qubits are encoded in a a large numbers of physical qubits. The encoding is maintained by constantly putting the physical qubits through a highly entangling circuit. Auxilliary degrees of freedom are also constantly measured, to detect signs of errors and allow their effects to be removed. The operations on the logical qubits required to implement quantum computation will be performed by essentially making small perturbations to this procedure.</p>
<p>Because of the vast amount effort required for this process, most operations performed in fault-tolerant quantum computers will be done to serve the purpose of error detection and correction. So when benchmarking our progress towards fault-tolerant quantum computation, we must keep track of how well our devices perform error correction.</p>
<p>In this chapter we will look at a particular example of error correction: the repetition code. Though not a true example of quantum error correction - it uses physical qubits to encode a logical <em>bit</em>, rather than a qubit - it serves as a simple guide to all the basic concepts in any quantum error correcting code. We will also see how it can be run on current prototype devices.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Introduction-to-the-repetition-code">Introduction to the repetition code<a class="anchor-link" href="#Introduction-to-the-repetition-code"> </a></h2>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-basics-of-error-correction">The basics of error correction<a class="anchor-link" href="#The-basics-of-error-correction"> </a></h3><p>The basic ideas behind error correction are the same for classical information as for classical information. This allows us to begin by considering a very straightforward example: speaking on the phone. If someone asks you a question to which the answer is 'yes' or 'no', the way you give your response will depend on two factors:</p>
<ul>
<li>How important is it that you are understood correctly?</li>
<li>How good is your connection?</li>
</ul>
<p>Both of these can be paramaterized with probabilities. For the first, we can use $P_a$, the maximum acceptable probability of being misunderstood. If you are being asked to confirm a preference for ice cream flavours, and don't mind too much if you get vanilla rather than chocolate, $P_a$ might be quite high. If you are being asked a question on which someone's life depends, however, $P_a$ will be much lower.</p>
<p>For the second we can use $p$, the probability that your answer is garbled by a bad connectiom. For simplicity, let's imagine a case where a garbled 'yes' doesn't simply sound like nonsense, but sounds like a 'no'. And similarly a 'no' is transformed into 'yes'. Then $p$ is the probability that you are completely misunderstood.</p>
<p>A good connection or a relatively unimportant question will result in $p&lt;P_a$. In this case it is fine to simply answer in the most direct way possible: you just say 'yes' or 'no'.</p>
<p>If, however, your connection is poor and your answer is important, we will have $p&gt;P_a$. A single 'yes' or 'no' is not enough in this case. The probability of being misunderstood would be too high. Instead we must encode our answer in a more complex structure, allowing the receiver to decode our meaning despite the possibility of the message being disrupted. The simplest method is the one that many would do without thinking: simply repeat the answer many times. For example say 'yes, yes, yes' instead of 'yes' or 'no, no no' instead of 'no'.</p>
<p>If the receiver hears 'yes, yes, yes' in this case, they will of course conclude that the sender meant 'yes'. If they hear 'no, yes, yes', 'yes, no, yes' or 'yes, yes, no', they will probably conclude the same thing, since there is more positivity than negativity in the answer. To be misunderstood in this case, at least two of the replies need to be garbled. The probability for this, $P$, will be less than $p$. When encoded in this way, the message therefore becomes more likely to be understood. The code cell below shows an example of this.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">**</span><span class="mi">3</span> <span class="c1"># probability of 2 or 3 errors</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Probability of a single reply being garbled:&#39;</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Probability of a the majority of three replies being garbled:&#39;</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Probability of a single reply being garbled: 0.01
Probability of a the majority of three replies being garbled: 0.00029800000000000003
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If $P&lt;P_a$, this technique solves our problem. If not, we can simply add more repetitions. The fact that $P&lt;p$ above comes from the fact that we need at least two replies to be garbled to flip the majority, and so even the most likely possibilities have a probability of $\sim p^2$. For five repetitions we'd need at least three replies to be garbled to flip the majority, which happens with probability $\sim p^3$. The value for $P$ in this case would then be even lower. Indeed, as we increase the number of repetitions, $P$ will decrease exponentially. No matter how bad the connection, or how certain we need to be of our message getting through correctly, we can acheive it by just repeating our answer enough times.</p>
<p>Though this is a simple example, it contains all the aspects of error correction.</p>
<ul>
<li>There is some information to be sent or stored: In this case, a 'yes' or 'no.</li>
<li>The information is encoded in a larger system to protect it against noise: In this case, by repeating the message.</li>
<li>The information is finally decoded, mitigating for the effects of noise: In this case, by trusting the majority of the transmitted messages.</li>
</ul>
<p>This same encoding scheme can also be used for binary, by simply substituting <code>0</code> and <code>1</code> for 'yes' and 'no. It can therefore also be easily generalized to qubits by using the states $\left|0\right\rangle$ and $\left|1\right\rangle$. In each case it is known as the <em>repetition code</em>. Many other forms of encoding are also possible in both the classical and quantum cases, which outperform the repetition code in many ways. However, its status as the simplest encoding does lend it to certain applications. One is exactly what it is used for in Qiskit: as the first and simplest test of implementing the ideas behind quantum error correction.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Correcting-errors-in-qubits">Correcting errors in qubits<a class="anchor-link" href="#Correcting-errors-in-qubits"> </a></h3><p>We will now implement these ideas explicitly using Qiskit. To see the effects of imperfect qubits, we simply can use the qubits of the prototype devices. We can also reproduce the effects in simulations. The function below creates a simple noise models in order to do this. These go beyond the simple case dicussed earlier, of a single noise event which happens with a probability $p$. Instead we consider two forms of error that can occur. One is a gate error: an imperfection in any operation we perform. We model this here in a simple way, using so-called depolarizing noise. The effect of this will be, with probabilty $p_{gate}$ ,to replace the state of any qubit with a completely random state. For two qubit gates, it is applied independently to each qubit. The other form of noise is that for measurement. This simply flips between a <code>0</code> to a <code>1</code> and vice-versa immediately before measurement with probability $p_{meas}$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.providers.aer.noise</span> <span class="kn">import</span> <span class="n">NoiseModel</span>
<span class="kn">from</span> <span class="nn">qiskit.providers.aer.noise.errors</span> <span class="kn">import</span> <span class="n">pauli_error</span><span class="p">,</span> <span class="n">depolarizing_error</span>

<span class="k">def</span> <span class="nf">get_noise</span><span class="p">(</span><span class="n">p_meas</span><span class="p">,</span><span class="n">p_gate</span><span class="p">):</span>

    <span class="n">error_meas</span> <span class="o">=</span> <span class="n">pauli_error</span><span class="p">([(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="n">p_meas</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_meas</span><span class="p">)])</span>
    <span class="n">error_gate1</span> <span class="o">=</span> <span class="n">depolarizing_error</span><span class="p">(</span><span class="n">p_gate</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">error_gate2</span> <span class="o">=</span> <span class="n">error_gate1</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">error_gate1</span><span class="p">)</span>

    <span class="n">noise_model</span> <span class="o">=</span> <span class="n">NoiseModel</span><span class="p">()</span>
    <span class="n">noise_model</span><span class="o">.</span><span class="n">add_all_qubit_quantum_error</span><span class="p">(</span><span class="n">error_meas</span><span class="p">,</span> <span class="s2">&quot;measure&quot;</span><span class="p">)</span> <span class="c1"># measurement error is applied to measurements</span>
    <span class="n">noise_model</span><span class="o">.</span><span class="n">add_all_qubit_quantum_error</span><span class="p">(</span><span class="n">error_gate1</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span> <span class="c1"># single qubit gate error is applied to x gates</span>
    <span class="n">noise_model</span><span class="o">.</span><span class="n">add_all_qubit_quantum_error</span><span class="p">(</span><span class="n">error_gate2</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;cx&quot;</span><span class="p">])</span> <span class="c1"># two qubit gate error is applied to cx gates</span>
        
    <span class="k">return</span> <span class="n">noise_model</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With this we'll now create such a noise model with a probability of $1\%$ for each type of error.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">noise_model</span> <span class="o">=</span> <span class="n">get_noise</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's see what affect this has when try to store a <code>0</code> using three qubits in state $\left|0\right\rangle$. We'll repeat the process <code>shots=1024</code> times to see how likely different results are.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">execute</span><span class="p">,</span> <span class="n">Aer</span>

<span class="n">qc0</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="c1"># initialize circuit with three qubits in the 0 state</span>

<span class="n">qc0</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qc0</span><span class="o">.</span><span class="n">qregs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qc0</span><span class="o">.</span><span class="n">cregs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># measure the qubits</span>

<span class="c1"># run the circuit with th noise model and extract the counts</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span> <span class="n">qc0</span><span class="p">,</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">),</span><span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>{&#39;001&#39;: 16, &#39;100&#39;: 8, &#39;000&#39;: 993, &#39;010&#39;: 7}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here we see that almost all results still come out <code>'000'</code>, as they would if there was no noise. Of the remaining possibilities, those with a majority of <code>0</code>s are most likely. In total, much less than 100 samples come out with a majority of <code>1</code>s. When using this circuit to encode a <code>0</code>, this means that $P&lt;1\%$</p>
<p>Now let's try the same for storing a <code>1</code> using three qubits in state $\left|1\right\rangle$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">qc1</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="c1"># initialize circuit with three qubits in the 0 state</span>
<span class="n">qc1</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qc1</span><span class="o">.</span><span class="n">qregs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># flip each 0 to 1</span>

<span class="n">qc1</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qc1</span><span class="o">.</span><span class="n">qregs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qc1</span><span class="o">.</span><span class="n">cregs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># measure the qubits</span>

<span class="c1"># run the circuit with th noise model and extract the counts</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span> <span class="n">qc1</span><span class="p">,</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">),</span><span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>{&#39;110&#39;: 14, &#39;101&#39;: 15, &#39;011&#39;: 19, &#39;111&#39;: 976}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The number of samples that come out with a majority in the wrong state (<code>0</code> in this case) is again much less than 100, so $P&lt;1\%$. Whether we store a <code>0</code> or a <code>1</code>, we can retrieve the information with a smaller probability of error than either of our sources of noise.</p>
<p>This was possible because the noise we considered was relatively weak. As we increase $p_{meas}$ and $p_{gate}$, the higher the probability $P$ will be. The extreme case of this is for either of them to have a $50/50$ chance of applying the bit flip error, <code>x</code>. For example, let's run the same circuit as before but with $p_{meas}=0.5$ and $p_{gate}=0$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">noise_model</span> <span class="o">=</span> <span class="n">get_noise</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span> <span class="n">qc1</span><span class="p">,</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">),</span><span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>{&#39;010&#39;: 126, &#39;110&#39;: 130, &#39;111&#39;: 113, &#39;000&#39;: 127, &#39;100&#39;: 117, &#39;001&#39;: 148, &#39;101&#39;: 134, &#39;011&#39;: 129}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With this noise, all outcomes occur with equal probability, with differences in results being due only to statistical noise. No trace of the encoded state remains. This is an important point to consider for error correction: sometimes the noise is too strong to be corrected. The optimal approach is to combine a good way of encoding the information you require, with hardware whose noise is not too strong.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Storing-qubits">Storing qubits<a class="anchor-link" href="#Storing-qubits"> </a></h3><p>So far, we have considered cases where there is no delay between encoding and decoding. For qubits, this means that there is no significant amount of time that passes between initializing the circuit, and making the final measurements.</p>
<p>However, there are many cases for which there will be a significant delay. As an obvious example, one may wish to encode a quantum state and store it for a long time, like a quantum hard drive. A less obvious but much more important example is performing fault-tolerant quantum computation itself. For this, we need to store quantum states and preserve their integrity during the computation. This must also be done in a way that allows us to manipulate the stored information in any way we need, and which corrects any errors we may introduce when performing the manipulations.</p>
<p>In all cases, we need account for the fact that errors do not only occur when something happens (like a gate or measurement), they also occur when the qubits are idle. Such noise is due to the fact that the qubits interact with each other and their environment. The longer we leave our qubits idle for, the greater the effects of this noise becomes. If we leave them for long enough, we'll encounter a situation like the $p_{meas}=0.5$ case above, where the noise is too strong for errors to be reliably corrected.</p>
<p>The solution is to keep measuring throughout. No qubit is left idle for too long. Instead, information is constantly being extracted from the system to keep track of the errors that have occurred.</p>
<p>For the case of classical information, where we simply wish to store a <code>0</code> or <code>1</code>, this can be done by just constantly measuring the value of each qubit. By keeping track of when the values change due to noise, we can easily deduce a history of when errors occurred.</p>
<p>For quantum information, however, it is not so easy. For example, consider the case that we wish to encode the logical state $\left|+\right\rangle$. Our encoding is such that</p>
$$\left|0\right\rangle \rightarrow \left|000\right\rangle,~~~ \left|1\right\rangle \rightarrow \left|111\right\rangle.$$<p>To encode the logical $\left|+\right\rangle$ state we therefore need</p>
$$\left|+\right\rangle=\frac{1}{\sqrt{2}}\left(\left|0\right\rangle+\left|1\right\rangle\right)\rightarrow \frac{1}{\sqrt{2}}\left(\left|000\right\rangle+\left|111\right\rangle\right).$$<p>With the repetition encoding that we are using, a z measurement (which distinguishes between the $\left|0\right\rangle$ and $\left|1\right\rangle$ states) of the logical qubit is done using a z measurement of each physical qubit. The final result for the logical measurement is decoded from the physical qubit measurement results by simply looking which output is in the majority.</p>
<p>As mentioned earlier, we can keep track of errors on logical qubits that are stored for a long time by constantly performing z measurements of the physical qubits. However, note that this effectively corresponds to constantly peforming z measurements of the physical qubits. This is fine if we are simply storing a <code>0</code> or <code>1</code>, but it has undesired effects if we are storing a superposition. Specifically: the first time we do such a check for errors, we will collapse the superposition.</p>
<p>This is not ideal. If we wanted to do some computation on our logical qubit, or is we wish to peform a basis change before final measurement, we need to preserve the superposition. Destroying it is an error. But this is not an error caused by imperfections in our devices. It is an error that we have introduced as part of our attempts to correct errors. And since we cannot hope to recreate any arbitrary superposition stored in our quantum computer, it is an error than cannot be corrected.</p>
<p>For this reason, we must find another way of keeping track of the errors that occur when our logical qubit is stored for long times. This should give us the information we need to detect and correct errors, and to decode the final measurment result with high probability. However, it should not cause uncorrectable errors to occur during the process by collapsing superpositions that we need to preserve.</p>
<p>The way to do this is with the following circuit element.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">ClassicalRegister</span>

<span class="n">cq</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;code\ qubit\ &#39;</span><span class="p">)</span>
<span class="n">lq</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;ancilla\ qubit\ &#39;</span><span class="p">)</span>
<span class="n">sb</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;syndrome\ bit\ &#39;</span><span class="p">)</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span><span class="n">lq</span><span class="p">,</span><span class="n">sb</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">cq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">lq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">cq</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">lq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">lq</span><span class="p">,</span><span class="n">sb</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/error-correction-repetition-code_18_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here we have three physical qubits. Two are called 'code qubits', and the other is called an 'ancilla qubit'. One bit of output is extracted, called the syndrome bit. The ancilla qubit is always initialized in state $\left|0\right\rangle$. The code qubits, however, can be initialized in different states. To see what affect different inputs have on the output, we can create a circuit <code>qc_init</code> that prepares the code qubits in some state, and then run the circuit <code>qc_init+qc</code>.</p>
<p>First, the trivial case: <code>qc_init</code> does nothing, and so the code qubits are initially $\left|00\right\rangle$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">qc_init</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">cq</span><span class="p">)</span>

<span class="p">(</span><span class="n">qc_init</span><span class="o">+</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/error-correction-repetition-code_20_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span> <span class="n">qc_init</span><span class="o">+</span><span class="n">qc</span><span class="p">,</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Results:&#39;</span><span class="p">,</span><span class="n">counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Results: {&#39;0&#39;: 1024}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The outcome, in all cases, is <code>0</code>.</p>
<p>Now let's try an initial state of $\left|11\right\rangle$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">qc_init</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">cq</span><span class="p">)</span>
<span class="n">qc_init</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">cq</span><span class="p">)</span>

<span class="p">(</span><span class="n">qc_init</span><span class="o">+</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/error-correction-repetition-code_23_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span> <span class="n">qc_init</span><span class="o">+</span><span class="n">qc</span><span class="p">,</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Results:&#39;</span><span class="p">,</span><span class="n">counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Results: {&#39;0&#39;: 1024}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The outcome in this case is also always <code>0</code>. Given the linearity of quantum mechanics, we can expect the same to be true also for any superposition of $\left|00\right\rangle$ and $\left|11\right\rangle$, such as the example below.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">qc_init</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">cq</span><span class="p">)</span>
<span class="n">qc_init</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">cq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc_init</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">cq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cq</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="p">(</span><span class="n">qc_init</span><span class="o">+</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/error-correction-repetition-code_26_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span> <span class="n">qc_init</span><span class="o">+</span><span class="n">qc</span><span class="p">,</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Results:&#39;</span><span class="p">,</span><span class="n">counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Results: {&#39;0&#39;: 1024}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The opposite outcome will be found for an initial state of $\left|01\right\rangle$, $\left|10\right\rangle$ or any superposition thereof.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">qc_init</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">cq</span><span class="p">)</span>
<span class="n">qc_init</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">cq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc_init</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">cq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cq</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc_init</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">cq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="p">(</span><span class="n">qc_init</span><span class="o">+</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/error-correction-repetition-code_29_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span> <span class="n">qc_init</span><span class="o">+</span><span class="n">qc</span><span class="p">,</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Results:&#39;</span><span class="p">,</span><span class="n">counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Results: {&#39;1&#39;: 1024}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In such cases the output is always <code>'1'</code>.</p>
<p>This measurement is therefore telling us about a collective property of multiple qubits. Specifically, it looks at the two code qubits and determines whether their state is the same or different in the z basis. For basis states that are the same in the z basis, like $\left|00\right\rangle$ and $\left|11\right\rangle$, the measurement simply returns <code>0</code>. It also does so for any superposition of these. Since it does not distinguish between these states in any way, it also does not collapse such a superposition.</p>
<p>Similarly, For basis states that are different in the z basis it returns a <code>1</code>. This occurs for $\left|01\right\rangle$, $\left|10\right\rangle$ or any superposition thereof.</p>
<p>Now suppose we apply such a 'syndrome measurement' on all pairs of physical qubits in our repetition code. If their state is described by a repeated $\left|0\right\rangle$, a repeated $\left|1\right\rangle$, or any superposition thereof, all the syndrome measurements will return <code>0</code>. Given this result, we will know that our states are indeed encoded in the repeated states that we want them to be, and can deduce that no errors have occurred. If some syndrome measurements return <code>1</code>, however, it is a signature of an error. We can therefore use these measurement results to determine how to decode the result.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Quantum-repetition-code">Quantum repetition code<a class="anchor-link" href="#Quantum-repetition-code"> </a></h3><p>We now know enough to understand exactly how the quantum version of the repetition code is implemented</p>
<p>We can use it in Qiskit by importing the required tools from Ignis.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.ignis.verification.topological_codes</span> <span class="kn">import</span> <span class="n">RepetitionCode</span>
<span class="kn">from</span> <span class="nn">qiskit.ignis.verification.topological_codes</span> <span class="kn">import</span> <span class="n">lookuptable_decoding</span>
<span class="kn">from</span> <span class="nn">qiskit.ignis.verification.topological_codes</span> <span class="kn">import</span> <span class="n">GraphDecoder</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We are free to choose how many physical qubits we want the logical qubit to be encoded in. We can also choose how many times the syndrome measurements will be applied while we store our logical qubit, before the final readout measurement. Let us start with the smallest non-trivial case: three repetitions and one syndrome measurement round. The circuits for the repetition code can then be created automatically from the using the <code>RepetitionCode</code> object from Qiskit-Ignis.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">code</span> <span class="o">=</span> <span class="n">RepetitionCode</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With this we can inspect various properties of the code, such as the names of the qubit registers used for the code and ancilla qubits.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <code>RepetitionCode</code> contains two quantum circuits that implement the code: One for each of the two possible logical bit values. Here are those for logical <code>0</code> and <code>1</code>, respectively.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># this bit is just needed to make the labels look nice</span>
<span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">code</span><span class="o">.</span><span class="n">circuit</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">qregs</span><span class="o">+</span><span class="n">code</span><span class="o">.</span><span class="n">circuit</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cregs</span><span class="p">:</span>
    <span class="n">reg</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;\ &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;\ &#39;</span>

<span class="n">code</span><span class="o">.</span><span class="n">circuit</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/error-correction-repetition-code_38_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">circuit</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/error-correction-repetition-code_39_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In these circuits, we have two types of physical qubits. There are the 'code qubits', which are the three physical qubits across which the logical state is encoded. There are also the 'link qubits', which serve as the ancilla qubits for the syndrome measurements.</p>
<p>Our single round of syndrome measurements in these circuits consist of just two syndrome measurements. One compares code qubits 0 and 1, and the other compares code qubits 1 and 2. One might expect that a further measurement, comparing code qubits 0 and 2, should be required to create a full set. However, these two are sufficient. This is because the information on whether 0 and 2 have the same z basis state can be inferred from the same information about 0 and 1 with that for 1 and 2. Indeed, for $n$ qubits, we can get the required information from just $n-1$ syndrome measurements of neighbouring pairs of qubits.</p>
<p>Running these circuits on a simulator without any noise leads to very simple results.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">get_raw_results</span><span class="p">(</span><span class="n">code</span><span class="p">,</span><span class="n">noise_model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="n">circuits</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">get_circuit_list</span><span class="p">()</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span> <span class="n">circuits</span><span class="p">,</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">),</span> <span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span> <span class="p">)</span>
    <span class="n">raw_results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">]:</span>
        <span class="n">raw_results</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">raw_results</span>

<span class="n">raw_results</span> <span class="o">=</span> <span class="n">get_raw_results</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="n">raw_results</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Logical&#39;</span><span class="p">,</span><span class="n">log</span><span class="p">,</span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="n">raw_results</span><span class="p">[</span><span class="n">log</span><span class="p">],</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Logical 0 : {&#39;000 00&#39;: 1024} 

Logical 1 : {&#39;111 00&#39;: 1024} 

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here we see that the output comes in two parts. The part on the right holds the outcomes of the two syndrome measurements. That on the left holds the outcomes of the three final measurements of the code qubits.</p>
<p>For more measurement rounds, $T=4$ for example, we would have the results of more syndrome measurements on the right.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">code</span> <span class="o">=</span> <span class="n">RepetitionCode</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

<span class="n">raw_results</span> <span class="o">=</span> <span class="n">get_raw_results</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="n">raw_results</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Logical&#39;</span><span class="p">,</span><span class="n">log</span><span class="p">,</span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="n">raw_results</span><span class="p">[</span><span class="n">log</span><span class="p">],</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Logical 0 : {&#39;000 00 00 00 00&#39;: 1024} 

Logical 1 : {&#39;111 00 00 00 00&#39;: 1024} 

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For more repetitions, $n=5$ for example, each set of measurements would be larger. The final measurement on the left would be of $n$ qubits. The $T$ syndrome measurements would each be of the $n-1$ possible neighbouring pairs.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">code</span> <span class="o">=</span> <span class="n">RepetitionCode</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

<span class="n">raw_results</span> <span class="o">=</span> <span class="n">get_raw_results</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="n">raw_results</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Logical&#39;</span><span class="p">,</span><span class="n">log</span><span class="p">,</span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="n">raw_results</span><span class="p">[</span><span class="n">log</span><span class="p">],</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Logical 0 : {&#39;00000 0000 0000 0000 0000&#39;: 1024} 

Logical 1 : {&#39;11111 0000 0000 0000 0000&#39;: 1024} 

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Lookup-table-decoding">Lookup table decoding<a class="anchor-link" href="#Lookup-table-decoding"> </a></h3><p>Now let's return to the $n=3$, $T=1$ example and look at a case with some noise.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">code</span> <span class="o">=</span> <span class="n">RepetitionCode</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">noise_model</span> <span class="o">=</span> <span class="n">get_noise</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.05</span><span class="p">)</span>

<span class="n">raw_results</span> <span class="o">=</span> <span class="n">get_raw_results</span><span class="p">(</span><span class="n">code</span><span class="p">,</span><span class="n">noise_model</span><span class="p">)</span>
<span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="n">raw_results</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Logical&#39;</span><span class="p">,</span><span class="n">log</span><span class="p">,</span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="n">raw_results</span><span class="p">[</span><span class="n">log</span><span class="p">],</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Logical 0 : {&#39;010 11&#39;: 3, &#39;001 10&#39;: 3, &#39;011 01&#39;: 1, &#39;010 10&#39;: 3, &#39;100 00&#39;: 49, &#39;110 01&#39;: 1, &#39;011 00&#39;: 6, &#39;010 01&#39;: 22, &#39;000 01&#39;: 84, &#39;101 00&#39;: 3, &#39;100 10&#39;: 3, &#39;000 10&#39;: 50, &#39;100 01&#39;: 9, &#39;000 00&#39;: 686, &#39;110 00&#39;: 4, &#39;011 10&#39;: 1, &#39;001 00&#39;: 45, &#39;001 01&#39;: 3, &#39;010 00&#39;: 44, &#39;000 11&#39;: 4} 

Logical 1 : {&#39;110 11&#39;: 3, &#39;101 01&#39;: 19, &#39;101 11&#39;: 25, &#39;001 11&#39;: 1, &#39;001 10&#39;: 4, &#39;011 01&#39;: 3, &#39;011 11&#39;: 4, &#39;010 10&#39;: 2, &#39;100 00&#39;: 6, &#39;110 01&#39;: 23, &#39;011 00&#39;: 46, &#39;111 01&#39;: 67, &#39;010 01&#39;: 6, &#39;100 11&#39;: 1, &#39;101 00&#39;: 43, &#39;100 10&#39;: 1, &#39;101 10&#39;: 7, &#39;100 01&#39;: 1, &#39;111 11&#39;: 12, &#39;110 10&#39;: 6, &#39;110 00&#39;: 42, &#39;011 10&#39;: 25, &#39;111 10&#39;: 76, &#39;001 00&#39;: 3, &#39;111 00&#39;: 589, &#39;001 01&#39;: 4, &#39;010 00&#39;: 5} 

</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here we have created <code>raw_results</code>, a dictionary that holds both the results for a circuit encoding a logical <code>0</code> and <code>1</code> encoded for a logical <code>1</code>.</p>
<p>Our task when confronted with any of the possible outcomes we see here is to determine what the outcome should have been, if there was no noise. For an outcome of <code>'000 00'</code> or <code>'111 00'</code>, the answer is obvious. These are the results we just saw for a logical <code>0</code> and logical <code>1</code>, respectively, when no errors occur. The former is the most common outcome for the logical <code>0</code> even with noise, and the latter is the most common for the logical <code>1</code>. We will therefore conclude that the outcome was indeed that for logical <code>0</code> whenever we encounter <code>'000 00'</code>, and the same for logical <code>1</code> when we encounter <code>'111 00'</code>.</p>
<p>Though this tactic is optimal, it can nevertheless fail. Note that <code>'111 00'</code> typically occurs in a handful of cases for an encoded <code>0</code>, and <code>'00 00'</code> similarly occurs for an encoded <code>1</code>. In this case, through no fault of our own, we will incorrectly decode the output. In these cases, a large number of errors conspired to make it look like we had a noiseless case of the opposite logical value, and so correction becomes impossible.</p>
<p>We can employ a similar tactic to decode all other outcomes. The outcome <code>'001 00'</code>, for example, occurs far more for a logical <code>0</code> than a logical <code>1</code>. This is because it could be caused by just a single measurement error in the former case (which incorrectly reports a single <code>0</code> to be <code>1</code>), but would require at least two errors in the latter. So whenever we see <code>'001 00'</code>, we can decode it as a logical <code>0</code>.</p>
<p>Applying this tactic over all the strings is a form of so-called 'lookup table decoding'. This is where every possible outcome is analyzed, and the most likely value to decode it as is determined. For many qubits, this quickly becomes intractable, as the number of possible outcomes becomes so large. In these cases, more algorithmic decoders are needed. However, lookup table decoding works well for testing out small codes.</p>
<p>We can use tools in Qiskit to implement lookup table decoding for any code. For this we need two sets of results. One is the set of results that we actually want to decode, and for which we want to calcate the probability of incorrect decoding, $P$. We will use the <code>raw_results</code> we already have for this.</p>
<p>The other set of results is one to be used as the lookup table. This will need to be run for a large number of samples, to ensure that it gets good statistics for each possible outcome. We'll use <code>shots=10000</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">circuits</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">get_circuit_list</span><span class="p">()</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span> <span class="n">circuits</span><span class="p">,</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">),</span> <span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">10000</span> <span class="p">)</span>
<span class="n">table_results</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">]:</span>
    <span class="n">table_results</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With this data, which we call <code>table_results</code>, we can now use the <code>lookuptable_decoding</code> function from Qiskit. This takes each outcome from <code>raw_results</code> and decodes it with the information in <code>table_results</code>. Then it checks if the decoding was correct, and uses this information to calculate $P$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">lookuptable_decoding</span><span class="p">(</span><span class="n">raw_results</span><span class="p">,</span><span class="n">table_results</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;P =&#39;</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>P = {&#39;0&#39;: 0.0285, &#39;1&#39;: 0.0184}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here we see that the values for $P$ are lower than those for $p_{meas}$ and $p_{gate}$, so we get an improvement in the reliability for storing the bit value. Note also that the value of $P$ for an encoded <code>1</code> is higher than that for <code>0</code>. This is because the encoding of <code>1</code> requires the application of <code>x</code> gates, which are an additional source of noise.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Graph-theoretic-decoding">Graph theoretic decoding<a class="anchor-link" href="#Graph-theoretic-decoding"> </a></h3><p>The decoding considered above produces the best possible results, and does so without needing to use any details of the code. However, it has a major drawback that counters these advantages: the lookup table grows exponentially large as code size increases. For this reason, decoding is typically done in a more algorithmic manner that takes into account the structure of the code and its resulting syndromes.</p>
<p>For the codes of <code>topological_codes</code> this structure is revealed using post-processing of the syndromes. Instead of using the form shown above, with the final measurement of the code qubits on the left and the outputs of the syndrome measurement rounds on the right, we use the <code>process_results</code> method of the code object to rewrite them in a different form.</p>
<p>For example, below is the processed form of a <code>raw_results</code> dictionary, in this case for $n=3$ and $T=2$. Only results with 50 or more samples are shown for clarity.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">code</span> <span class="o">=</span> <span class="n">RepetitionCode</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="n">raw_results</span> <span class="o">=</span> <span class="n">get_raw_results</span><span class="p">(</span><span class="n">code</span><span class="p">,</span><span class="n">noise_model</span><span class="p">)</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">process_results</span><span class="p">(</span> <span class="n">raw_results</span> <span class="p">)</span>

<span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Logical &#39;</span> <span class="o">+</span> <span class="n">log</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;raw results       &#39;</span><span class="p">,</span> <span class="p">{</span><span class="n">string</span><span class="p">:</span><span class="n">raw_results</span><span class="p">[</span><span class="n">log</span><span class="p">][</span><span class="n">string</span><span class="p">]</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">raw_results</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="k">if</span> <span class="n">raw_results</span><span class="p">[</span><span class="n">log</span><span class="p">][</span><span class="n">string</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">50</span> <span class="p">})</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;processed results &#39;</span><span class="p">,</span> <span class="p">{</span><span class="n">string</span><span class="p">:</span><span class="n">results</span><span class="p">[</span><span class="n">log</span><span class="p">][</span><span class="n">string</span><span class="p">]</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="n">log</span><span class="p">]</span> <span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="n">log</span><span class="p">][</span><span class="n">string</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">50</span> <span class="p">})</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
Logical 0:
raw results        {&#39;000 00 01&#39;: 70, &#39;000 00 00&#39;: 473}
processed results  {&#39;0 0  01 01 00&#39;: 70, &#39;0 0  00 00 00&#39;: 473}

Logical 1:
raw results        {&#39;111 01 00&#39;: 59, &#39;111 00 00&#39;: 457}
processed results  {&#39;1 1  00 01 01&#39;: 59, &#39;1 1  00 00 00&#39;: 457}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here we can see that <code>'000 00 00'</code> has been transformed to <code>'0 0  00 00 00'</code>, and <code>'111 00 00'</code> to <code>'1 1  00 00 00'</code>, and so on.</p>
<p>In these new strings, the <code>0 0</code> to the far left for the logical <code>0</code> results and the <code>1 1</code> to the far left of the logical <code>1</code> results are the logical readout. Any code qubit could be used for this readout, since they should (without errors) all be equal. It would therefore be possible in principle to just have a single <code>0</code> or <code>1</code> at this position. We could also do as in the original form of the result and have $n$, one for each qubit. Instead we use two, from the two qubits at either end of the line. The reason for this will be shown later. In the absence of errors, these two values will always be equal, since they represent the same encoded bit value.</p>
<p>After the logical values follow the $n-1$ results of the syndrome measurements for the first round. A <code>0</code> implies that the corresponding pair of qubits have the same value, and <code>1</code> implies they they are different from each other. There are $n-1$ results because the line of $d$ code qubits has $n-1$ possible neighboring pairs. In the absence of errors, they will all be <code>0</code>. This is exactly the same as the first such set of syndrome results from the original form of the result.</p>
<p>The next block is the next round of syndrome results. However, rather than presenting these results directly, it instead gives us the syndrome change between the first and second rounds. It is therefore the bitwise <code>OR</code> of the syndrome measurement results from the second round with those from the first. In the absence of errors, they will all be <code>0</code>.</p>
<p>Any subsequent blocks follow the same formula, though the last of all requires some comment. This is not measured using the standard method (with a link qubit). Instead it is calculated from the final readout measurement of all code qubits. Again it is presented as a syndrome change, and will be all <code>0</code> in the absence of errors. This is the $T+1$-th block of syndrome measurements since, as it is not done in the same way as the others, it is not counted among the $T$ syndrome measurement rounds.</p>
<p>The following examples further illustrate this convention.</p>
<p><strong>Example 1:</strong> <code>0 0  0110 0000 0000</code> represents a $d=5$, $T=2$ repetition code with encoded <code>0</code>. The syndrome shows that (most likely) the middle code qubit was flipped by an error before the first measurement round. This causes it to disagree with both neighboring code qubits for the rest of the circuit. This is shown by the syndrome in the first round, but the blocks for subsequent rounds do not report it as it no longer represents a change. Other sets of errors could also have caused this syndrome, but they would need to be more complex and so presumably less likely.</p>
<p><strong>Example 2:</strong> <code>0 0  0010 0010 0000</code> represents a $d=5$, $T=2$ repetition code with encoded <code>0</code>. Here one of the syndrome measurements reported a difference between two code qubits in the first round, leading to a <code>1</code>. The next round did not see the same effect, and so resulted in a <code>0</code>. However, since this disagreed with the previous result for the same syndrome measurement, and since we track syndrome changes, this change results in another <code>1</code>. Subsequent rounds also do not detect anything, but this no longer represents a change and hence results in a <code>0</code> in the same position. Most likely the measurement result leading to the first <code>1</code> was an error.</p>
<p><strong>Example 3:</strong> <code>0 1  0000 0001 0000</code> represents a $d=5$, $T=2$ repetition code with encoded <code>1</code>. A code qubit on the end of the line is flipped before the second round of syndrome measurements. This is detected by only a single syndrome measurement, because it is on the end of the line. For the same reason, it also disturbs one of the logical readouts.</p>
<p>Note that in all these examples, a single error causes exactly two characters in the string to change from the value they would have with no errors. This is the defining feature of the convention used to represent stabilizers in <code>topological_codes</code>. It is used to define the graph on which the decoding problem is defined.</p>
<p>Specifically, the graph is constructed by first taking the circuit encoding logical <code>0</code>, for which all bit values in the output string should be <code>0</code>. Many copies of this and then created and run on a simulator, with a different single Pauli operator inserted into each. This is done for each of the three types of Pauli operator on each of the qubits and at every circuit depth. The output from each of these circuits can be used to determine the effects of each possible single error. Since the circuit contains only Clifford operations, the simulation can be performed efficiently.</p>
<p>In each case, the error will change exactly two of the characters (unless it has no effect). A graph is then constructed for which each bit of the output string corresponds to a node, and the pairs of bits affected by the same error correspond to an edge.</p>
<p>The process of decoding a particular output string typically requires the algorithm to deduce which set of errors occured, given the syndrome found in the output string. This can be done by constructing a second graph, containing only nodes that correspond to non-trivial syndrome bits in the output. An edge is then placed between each pair of nodes, with an corresponding weight equal to the length of the minimal path between those nodes in the original graph. A set of errors consistent with the syndrome then corresponds then to finding a perfect matching of this graph. To deduce the most likely set of errors to have occurred, a good tactic would be to find one with the least possible number of errors that is consistent with the observed syndrome. This corresponds to a minimum weight perfect matching of the graph.</p>
<p>Using minimal weight perfect matching is a standard decoding technique for the repetition code and surface code, and is implement in Qiskit Ignis. It can also be used in other cases, such as Color codes, but it does not find the best approximation of the most likely set of errors for every code and noise model. For that reason, other decoding technques based on the same graph can be used. The <code>GraphDecoder</code> of Qiskit Ignis calculates these graphs for a given code, and will provide a range of methods to analyze it. At time of writing, only minimum weight perfect matching is implemented.</p>
<p>Note that, for codes such as the surface code, it is not strictly true than each single error will change the value of only two bits in the output string. A $\sigma^y$ error, for example would flip a pair of values corresponding to two different types of stabilizer, which are typically decoded independently. Output for these codes will therefore be presented in a way that acknowledges this, and analysis of such syndromes will correspondingly create multiple independent graphs to represent the different syndrome types.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Running-a-repetition-code-benchmarking-procedure">Running a repetition code benchmarking procedure<a class="anchor-link" href="#Running-a-repetition-code-benchmarking-procedure"> </a></h2><p>We will now run examples of repetition codes on real devices, and use the results as a benchmark. First, we will breifly summarize the process. This applies to this example of the repetition code, but also for other benchmarking procedures in <code>topological_codes</code>, and indeed for Qiskit Ignis in general. In each case, the following three-step process is used.</p>
<ol>
<li>A task is defined. Qiskit Ignis determines the set of circuits that must be run and creates them.</li>
<li>The circuits are run. This is typically done using Qiskit. However, in principle any service or experimental equipment could be interfaced.</li>
<li>Qiskit Ignis is used to process the results from the circuits, to create the output required for the given task.</li>
</ol>
<p>For <code>topological_codes</code>, step 1 requires the type and size of quantum error correction code to be chosen. Each type of code has a dedicated Python class. A corresponding object is initialized by providing the paramters required, such as <code>n</code> and <code>T</code> for a <code>RepetitionCode</code> object. The resulting object then contains the circuits corresponding to the given code encoding simple logical qubit states (such as $\left|0\right\rangle$ and $\left|1\right\rangle$), and then running the procedure of error detection for a specified number of rounds, before final readout in a straightforward logical basis (typically a standard $\left|0\right\rangle$/$\left|1\right\rangle$ measurement).</p>
<p>For <code>topological_codes</code>, the main processing of step 3 is the decoding, which aims to mitigate for any errors in the final readout by using the information obtained from error detection. The optimal algorithm for decoding typically varies between codes. However, codes with similar structure often make use of similar methods.</p>
<p>The aim of <code>topological_codes</code> is to provide a variety of decoding methods, implemented such that all the decoders can be used on all of the codes. This is done by restricting to codes for which decoding can be described as a graph-theoretic minimization problem. This classic example of such codes are the toric and surface codes. The property is also shared by 2D color codes and matching codes. All of these are prominent examples of so-called topological quantum error correcting codes, which led to the name of the subpackage. However, note that not all topological codes are compatible with such a decoder. Also, some non-topological codes will be compatible, such as the repetition code.</p>
<p>The decoding is done by the <code>GraphDecoder</code> class. A corresponding object is initialiazed by providing the code object for which the decoding will be performed. This is then used to determine the graph on which the decoding problem will be defined. The results can then be processed using the various methods of the decoder object.</p>
<p>In the following we will see the above ideas put into practice for the repetition code. In doing this we will employ two Boolean variables, <code>step_2</code> and <code>step_3</code>. The variable <code>step_2</code> is used to show which parts of the program need to be run when taking data from a device, and <code>step_3</code> is used to show the parts which process the resulting data.</p>
<p>Both are set to false by default, to ensure that all the program snippets below can be run using only previously collected and processed data. However, to obtain new data one only needs to use <code>step_2 = True</code>, and perform decoding on any data one only needs to use <code>step_3 = True</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">step_2</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">step_3</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To benchmark a real device we need the tools required to access that device over the cloud, and compile circuits suitable to run on it. These are imported as follows.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">IBMQ</span>
<span class="kn">from</span> <span class="nn">qiskit.compiler</span> <span class="kn">import</span> <span class="n">transpile</span>
<span class="kn">from</span> <span class="nn">qiskit.transpiler</span> <span class="kn">import</span> <span class="n">PassManager</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can now create the backend object, which is used to run the circuits. This is done by supplying the string used to specify the device. Here <code>'ibmq_16_melbourne'</code> is used, which has 15 active qubits at time of writing. We will also consider the 53 qubit <em>Rochester</em> device, which is specified with <code>'ibmq_rochester'</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">device_name</span> <span class="o">=</span> <span class="s1">&#39;ibmq_16_melbourne&#39;</span>

<span class="k">if</span> <span class="n">step_2</span><span class="p">:</span>
    
    <span class="n">IBMQ</span><span class="o">.</span><span class="n">load_account</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">provider</span> <span class="ow">in</span> <span class="n">IBMQ</span><span class="o">.</span><span class="n">providers</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">potential_backend</span> <span class="ow">in</span> <span class="n">provider</span><span class="o">.</span><span class="n">backends</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">potential_backend</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">==</span><span class="n">device_name</span><span class="p">:</span>
                <span class="n">backend</span> <span class="o">=</span> <span class="n">potential_backend</span>

    <span class="n">coupling_map</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">coupling_map</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>When running a circuit on a real device, a transpilation process is first implemented. This changes the gates of the circuit into the native gate set implement by the device. In some cases these changes are fairly trivial, such as expressing each Hadamard as a single qubit rotation by the corresponding Euler angles. However, the changes can be more major if the circuit does not respect the connectivity of the device. For example, suppose the circuit requires a controlled-NOT that is not directly implemented by the device. The effect must be then be reproduced with techniques such as using additional controlled-NOT gates to move the qubit states around. As well as introducing additional noise, this also delocalizes any noise already present. A single qubit error in the original circuit could become a multiqubit monstrosity under the action of the additional transpilation. Such non-trivial transpilation must therefore be prevented when running quantum error correction circuits.</p>
<p>Tests of the repetition code require qubits to be effectively ordered along a line. The only controlled-NOT gates required are between neighbours along that line. Our first job is therefore to study the coupling map of the device, and find a line.</p>
<p><img src="images/melbourne.png" alt="Fig. 1. The coupling map of the IBM Q Melbourne device."></p>
<p>For Melbourne it is possible to find a line that covers all 15 qubits. The choice one specified in the list <code>line</code> below is designed to avoid the most error prone <code>cx</code> gates. For the 53 qubit <em>Rochester</em> device, there is no single line that covers all 53 qubits. Instead we can use the following choice, which covers 43.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">if</span> <span class="n">device_name</span><span class="o">==</span><span class="s1">&#39;ibmq_16_melbourne&#39;</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="k">elif</span> <span class="n">device_name</span><span class="o">==</span><span class="s1">&#39;ibmq_rochester&#39;</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="c1">#,0,1,2,3,4,6,13,14,15,18,27,26,25,29,36,37,38,41,50,49,48,47,46,45,44,43,42,39,30,31]</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we know how many qubits we have access to, we can create the repetition code objects for each code that we will run. Note that a code with <code>n</code> repetitions uses $n$ code qubits and $n-1$ link qubits, and so $2n-1$ in all.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">n_min</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">n_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

<span class="n">code</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_min</span><span class="p">,</span><span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">code</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">RepetitionCode</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Before running the circuits from these codes, we need to ensure that the transpiler knows which physical qubits on the device it should use. This means using the qubit of <code>line[0]</code> to serve as the first code qubit, that of <code>line[1]</code> to be the first link qubit, and so on. This is done by the following function, which takes a repetition code object and a <code>line</code>, and creates a Python dictionary to specify which qubit of the code corresponds to which element of the line.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">get_initial_layout</span><span class="p">(</span><span class="n">code</span><span class="p">,</span><span class="n">line</span><span class="p">):</span>
    <span class="n">initial_layout</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">initial_layout</span><span class="p">[</span><span class="n">code</span><span class="o">.</span><span class="n">code_qubit</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">initial_layout</span><span class="p">[</span><span class="n">code</span><span class="o">.</span><span class="n">link_qubit</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">initial_layout</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we can transpile the circuits, to create the circuits that will actually be run by the device. A check is also made to ensure that the transpilation indeed has not introduced non-trivial effects by increasing the number of qubits. Furthermore, the compiled circuits are collected into a single list, to allow them all to be submitted at once in the same batch job.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">if</span> <span class="n">step_2</span><span class="p">:</span>
    
    <span class="n">circuits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_min</span><span class="p">,</span><span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">initial_layout</span> <span class="o">=</span> <span class="n">get_initial_layout</span><span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">line</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">]:</span>
            <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">transpile</span><span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">circuit</span><span class="p">[</span><span class="n">log</span><span class="p">],</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">initial_layout</span><span class="o">=</span><span class="n">initial_layout</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">num_cx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">count_ops</span><span class="p">())[</span><span class="s1">&#39;cx&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">num_cx</span><span class="o">==</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_cx</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; instead of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; cx gates for n = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We are now ready to run the job. As with the simulated jobs considered already, the results from this are extracted into a dictionary <code>raw_results</code>. However, in this case it is extended to hold the results from different code sizes. This means that <code>raw_results[n]</code> in the following is equivalent to one of the <code>raw_results</code> dictionaries used earlier, for a given <code>n</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">if</span> <span class="n">step_2</span><span class="p">:</span>
    
    <span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuits</span><span class="p">,</span><span class="n">backend</span><span class="p">,</span><span class="n">shots</span><span class="o">=</span><span class="mi">8192</span><span class="p">)</span>

    <span class="n">raw_results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_min</span><span class="p">,</span><span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">raw_results</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="s1">&#39;1&#39;</span><span class="p">]:</span>
            <span class="n">raw_results</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">log</span><span class="p">]</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It can be convenient to save the data to file, so that the processing of step 3 can be done or repeated at a later time.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">if</span> <span class="n">step_2</span><span class="p">:</span> <span class="c1"># save results</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results/raw_results_&#39;</span><span class="o">+</span><span class="n">device_name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">raw_results</span><span class="p">))</span>
<span class="k">elif</span> <span class="n">step_3</span><span class="p">:</span> <span class="c1"># read results</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results/raw_results_&#39;</span><span class="o">+</span><span class="n">device_name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">raw_results</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As we saw previously, the process of decoding first needs the results to be rewritten in order for the syndrome to be expressed in the correct form. As such, the <code>process_results</code> method of each the repetition code object <code>code[n]</code> is used to create determine a results dictionary <code>results[n]</code> from each <code>raw_results[n]</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">if</span> <span class="n">step_3</span><span class="p">:</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_min</span><span class="p">,</span><span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">results</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">process_results</span><span class="p">(</span> <span class="n">raw_results</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The decoding also needs us to set up the <code>GraphDecoder</code> object for each code. The initialization of these involves the construction of the graph corresponding to the syndrome, as described in the last section.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">if</span> <span class="n">step_3</span><span class="p">:</span>
    <span class="n">dec</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_min</span><span class="p">,</span><span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">dec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">GraphDecoder</span><span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, the decoder object can be used to process the results. Here the default algorithm, minimim weight perfect matching, is used. The end result is a calculation of the logical error probability. When running step 3, the following snippet also saves the logical error probabilities. Otherwise, it reads in previously saved probabilities.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">if</span> <span class="n">step_3</span><span class="p">:</span>
    
    <span class="n">logical_prob_match</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_min</span><span class="p">,</span><span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">logical_prob_match</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">dec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get_logical_prob</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results/logical_prob_match_&#39;</span><span class="o">+</span><span class="n">device_name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">logical_prob_match</span><span class="p">))</span>
        
<span class="k">else</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results/logical_prob_match_&#39;</span><span class="o">+</span><span class="n">device_name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">logical_prob_match</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The resulting logical error probabilities are displayed in the following graph, whch uses a log scale used on the y axis. We would expect that the logical error probability decays exponentially with increasing $n$. If this is the case, it is a confirmation that the device is compatible with this basis test of quantum error correction. If not, it implies that the qubits and gates are not sufficiently reliable.</p>
<p>Fortunately, the results from IBM Q prototype devices typically do show the expected exponential decay. For the results below, we can see that small codes do represent an exception to this rule. Other deviations can also be expected, such as when the increasing the size of the code means uses a group of qubits with either exceptionally low or high noise.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">x_axis</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_min</span><span class="p">,</span><span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="p">{</span> <span class="n">log</span><span class="p">:</span> <span class="p">[</span><span class="n">logical_prob_match</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">log</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">x_axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">log</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]</span> <span class="p">}</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Code distance, n&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;ln(Logical error probability)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">x_axis</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;logical 0&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">x_axis</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;logical 1&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymax</span><span class="o">=</span><span class="mf">1.5</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">P</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]),</span><span class="n">ymin</span><span class="o">=</span><span class="mf">0.75</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">P</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/error-correction-repetition-code_81_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Another insight we can gain is to use the results to determine how likely certain error processes are to occur.</p>
<p>To do this we use the fact that each edge in the syndrome graph represents a particular form of error, occuring on a particular qubit at a particular point within the circuit. This is the unique single error that causes the syndrome values corresponding to both of the adjacent nodes to change. Using the results to estimate the probability of such a syndrome therefore allows us to estimate the probability of such an error event. Specifically, to first order it is clear that</p>
$$
\frac{p}{1-p} \approx \frac{C_{11}}{C_{00}}
$$<p>Here $p$ is the probaility of the error corresponding to a particular edge, $C_{11}$ is the number of counts in the <code>results[n]['0']</code> correponding to the syndrome value of both adjacent nodes being <code>1</code>, and $C_{00}$ is the same for them both being <code>0</code>.</p>
<p>The decoder object has a method <code>weight_syndrome_graph</code> which determines these ratios, and assigns each edge the weight $-\ln(p/(1-p))$. By employing this method and inspecting the weights, we can easily retreive these probabilities.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">if</span> <span class="n">step_3</span><span class="p">:</span>

    <span class="n">dec</span><span class="p">[</span><span class="n">n_max</span><span class="p">]</span><span class="o">.</span><span class="n">weight_syndrome_graph</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="n">results</span><span class="p">[</span><span class="n">n_max</span><span class="p">])</span>

    <span class="n">probs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">dec</span><span class="p">[</span><span class="n">n_max</span><span class="p">]</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dec</span><span class="p">[</span><span class="n">n_max</span><span class="p">]</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="s1">&#39;distance&#39;</span><span class="p">])</span>
        <span class="n">probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">ratio</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">ratio</span><span class="p">)</span> <span class="p">)</span>
        
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results/probs_&#39;</span><span class="o">+</span><span class="n">device_name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">probs</span><span class="p">))</span>
        
<span class="k">else</span><span class="p">:</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results/probs_&#39;</span><span class="o">+</span><span class="n">device_name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Rather than display the full list, we can obtain a summary via the mean, standard devation, minimum, maximum and quartiles.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>{&#39;count&#39;: 29.0,
 &#39;mean&#39;: 0.18570187935383517,
 &#39;std&#39;: 0.12966061187100628,
 &#39;min&#39;: 0.014967523298503253,
 &#39;25%&#39;: 0.05383187483426147,
 &#39;50%&#39;: 0.1799797775530839,
 &#39;75%&#39;: 0.2753350576063955,
 &#39;max&#39;: 0.4345054945054945}</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The benchmarking of the devices does not produce any set of error probabilities that is exactly equivalent. However, the probabilities for readout errors and controlled-NOT gate errors could serve as a good comparison. Specifically, we can use the <code>backend</code> object to obtain these values from the benchmarking.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">if</span> <span class="n">step_3</span><span class="p">:</span>

    <span class="n">gate_probs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">qubit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
        
        <span class="n">gate_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">backend</span><span class="o">.</span><span class="n">properties</span><span class="p">()</span><span class="o">.</span><span class="n">readout_error</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="n">cx1</span><span class="p">,</span><span class="n">cx2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
        <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">gate_probs</span><span class="p">(</span> <span class="n">backend</span><span class="o">.</span><span class="n">properties</span><span class="p">()</span><span class="o">.</span><span class="n">gate_error</span><span class="p">(</span><span class="s1">&#39;cx&#39;</span><span class="p">,[</span><span class="n">qubit</span><span class="p">,</span><span class="n">line</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">gate_probs</span><span class="p">(</span> <span class="n">backend</span><span class="o">.</span><span class="n">properties</span><span class="p">()</span><span class="o">.</span><span class="n">gate_error</span><span class="p">(</span><span class="s1">&#39;cx&#39;</span><span class="p">,[</span><span class="n">qubit</span><span class="p">,</span><span class="n">line</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span> <span class="p">)</span>
                
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results/gate_probs_&#39;</span><span class="o">+</span><span class="n">device_name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">gate_probs</span><span class="p">))</span>
        
<span class="k">else</span><span class="p">:</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;results/gate_probs_&#39;</span><span class="o">+</span><span class="n">device_name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">gate_probs</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
    
<span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">gate_probs</span><span class="p">)</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>{&#39;count&#39;: 15.0,
 &#39;mean&#39;: 0.08386929848831581,
 &#39;std&#39;: 0.06860851140104485,
 &#39;min&#39;: 0.02134613228239715,
 &#39;25%&#39;: 0.050219500857068944,
 &#39;50%&#39;: 0.05460651866864599,
 &#39;75%&#39;: 0.09450000000000003,
 &#39;max&#39;: 0.28}</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If the results above are orders of magnitude different from those obtained in the repetition code, we would have cause to worry that one is seeing the effects of errors that the other does not. However, we typically see relatively good agreement.</p>
<p>Clearly, further analysis could be made. Such as comparing different runs, and using different possible choices for <code>line</code>, to get a greater insight into a device. However, here we limit outselves to simply showing the most straightforward results that can be obtained from a repetition code.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Summary">Summary<a class="anchor-link" href="#Summary"> </a></h3><p>The repetition code is a simple example of the basic principles of quantum error correction. These are as follows.</p>
<ol>
<li><p>The information we wish to store and process takes the form of 'logical qubits'. The states of these are encoded across many of the actual 'physical qubits' of a device.</p>
</li>
<li><p>Information about errors is extracted constantly through a process of 'syndrome' measurement. These consist of measurements that extract no information about the logical stored information. Instead they assess collective properties of groups of physical qubits, in order to determine when faults arise in the encoding of the logical qubits.</p>
</li>
<li><p>The information from syndrome measurements allows the effects of errors to be identified and mitigated for with high probability. This requires a decoding method.</p>
</li>
</ol>
<p>There is another basic principle for which the repetition code is not such a good example.</p>
<ol>
<li>Manipulating stored information must require action on multiple physical qubits. The minimum number required for any code is is known as the distance of the code, $d$. Possible manipulations include performing an <code>x</code> operation on the logical qubit (flipping an encoded $\left|0\right\rangle$ to an encoded $\left|1\right\rangle$, and vice-versa), or performing a logical z measurement (distinguishing an encoded $\left|0\right\rangle$ from an encoded $\left|1\right\rangle$).</li>
</ol>
<p>This makes it harder to perform operations on logical qubits when required: both for us, and for errors. The latter is, of course, the reason why this behaviour is required. If logical information could be acessed using only a single physical qubit, it would always be possible for single stray errors to disturb the logical qubit. The aim is usually to make it relatively straightforward for us to perform logical operations, given that we know how to do it, but hard for noise to achieve it by random chance.</p>
<p>In terms of making it hard for noise to peform a logical <code>x</code>, the repetition code cannot be beaten: All code qubits must be flipped to flip the logical value. From this perspective, $d=n$. For a z measurement, however, the repetition code is very poor. In the ideal case of no errors, the logical z basis information is repeated across every code qubit. Measuring any single code qubit is therefore sufficient to deduce the logical value. For this logical operation, and the overal distance, is therefore $d=1$ for the repetition code. This is also reflected by the fact that the code is unable to detect and correct logical <code>z</code> errors.</p>
<p>For a better example of quantum error correction, we therefore need to find alternatives to the repetition approach. One of the foremost examples is the surface code, which will be added to this textbook as soon as it is implemented in Ignis.</p>

</div>
</div>
</div>
</div>

 


    </main>
    
        </div>
        <nav class="c-page__nav">
  
    
    <a id="js-page__nav__prev" class="c-page__nav__prev" href="/textbook-master/ch-quantum-hardware/calibrating-qubits-openpulse.html">
       <span class="u-margin-right-tiny"></span> 
    </a>
  

  
    
    <a id="js-page__nav__next" class="c-page__nav__next" href="/textbook-master/ch-quantum-hardware/measurement-error-mitigation.html">
       <span class="u-margin-right-tiny"></span> 
    </a>
  
</nav>

        <footer>
  <p class="footer">This page was created by <a href="https://github.com/jupyter/jupyter-book/graphs/contributors">The Jupyter Book Community</a></p>
</footer>

      </main>
    </div>
  </body>
</html>
