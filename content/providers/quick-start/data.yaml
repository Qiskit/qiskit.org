---
!!seq [
  !!map {
    ? !!str "title"
    : !!str "Qiskit (with built-in simulator)",
    ? !!str "description"
    : !!str "Run quantum circuits and algorithms using Qiskit as a stand-alone tool\
      \ with its reference implementations of simulators.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://qiskit.org/documentation/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/Qiskit/qiskit-terra",
    },
    ? !!str "installation"
    : !!str "pip install qiskit",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "# Build circuit\nfrom qiskit.circuit.library import QuantumVolume\n\
          circuit = QuantumVolume(5)\n\n# Transpile circuit\nfrom qiskit import transpile\n\
          transpiled_circuit = transpile(circuit, basis_gates=['sx', 'rz', 'cx'])\n\
          transpiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit.primitives import Sampler\nsampler = Sampler()\n\n# Build\
          \ circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit.primitives import Estimator\nestimator = Estimator()\n\
          \n# Express hydrogen molecule Hamiltonian as an operator\nfrom qiskit.quantum_info\
          \ import SparsePauliOp\nH2_operator = SparsePauliOp.from_list([\n    (\"\
          II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"\
          ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"\
          XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using\
          \ VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers\
          \ import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\
          \nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"\
          cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator, ansatz, optimizer)\n\
          result = vqe.compute_minimum_eigenvalue(operator=H2_operator)\nprint(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "Aer",
    ? !!str "description"
    : !!str "Aer is a high performance simulator for quantum circuits that includes\
      \ noise models.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://qiskit.org/ecosystem/aer/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/Qiskit/qiskit-aer",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit-aer",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_aer import AerSimulator\nbackend = AerSimulator()\n\n\
          # Build circuit\nfrom qiskit.circuit.library import QuantumVolume\ncircuit\
          \ = QuantumVolume(5)\n\n# Transpile circuit\nfrom qiskit import transpile\n\
          transpiled_circuit = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_aer.primitives import Sampler\nsampler = Sampler()\n\n\
          # Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_aer.primitives import Estimator\nestimator = Estimator()\n\
          \n# Express hydrogen molecule Hamiltonian as an operator\nfrom qiskit.quantum_info\
          \ import SparsePauliOp\nH2_operator = SparsePauliOp.from_list([\n    (\"\
          II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"\
          ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"\
          XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using\
          \ VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers\
          \ import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\
          \nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"\
          cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator, ansatz, optimizer)\n\
          result = vqe.compute_minimum_eigenvalue(operator=H2_operator)\nprint(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "IBM Quantum",
    ? !!str "description"
    : !!str "IBM Quantum offers both open and premium access to a wide variety of\
      \ quantum systems. All quantum systems deployed by IBM Quantum are based on\
      \ superconducting qubit technology, as the control and scalability of this technology\
      \ pave a clear path to achieving quantum advantage with these systems.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://qiskit.org/documentation/partners/qiskit_ibm_provider/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/Qiskit/qiskit-ibm-provider",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit-ibm-provider qiskit-ibm-runtime",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_ibm_provider import IBMProvider\n\n# Get the API token\
          \ in https://quantum-computing.ibm.com/account\nprovider = IBMProvider(token=\"\
          MY_IBM_QUANTUM_TOKEN\")\nbackend = provider.get_backend(\"ibm_nairobi\"\
          )\n\n# Build circuit\nfrom qiskit.circuit.library import QuantumVolume\n\
          circuit = QuantumVolume(5)\n\n# Transpile circuit\nfrom qiskit import transpile\n\
          transpiled_circuit = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_ibm_runtime import QiskitRuntimeService, Sampler\n\n\
          # Get the API token in https://quantum-computing.ibm.com/account\nservice\
          \ = QiskitRuntimeService(channel=\"ibm_quantum\", token=\"MY_IBM_QUANTUM_TOKEN\"\
          )\nbackend = service.backend(\"ibm_perth\")\nsampler = Sampler(session=backend)\n\
          \n# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_ibm_runtime import QiskitRuntimeService, Estimator\n\n\
          # Get the API token in https://quantum-computing.ibm.com/account\nservice\
          \ = QiskitRuntimeService(channel=\"ibm_quantum\", token=\"MY_IBM_QUANTUM_TOKEN\"\
          )\nbackend = service.backend(\"ibm_perth\")\nestimator = Estimator(session=backend)\n\
          \n# Express hydrogen molecule Hamiltonian as an operator\nfrom qiskit.quantum_info\
          \ import SparsePauliOp\nH2_operator = SparsePauliOp.from_list([\n    (\"\
          II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"\
          ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"\
          XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using\
          \ VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers\
          \ import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\
          \nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"\
          cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator, ansatz, optimizer)\n\
          result = vqe.compute_minimum_eigenvalue(operator=H2_operator)\nprint(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "IonQ",
    ? !!str "description"
    : !!str "IonQ offers access to Ytterbium trapped-ion quantum computers with high\
      \ gate fidelity, long coherence time and all-to-all connectivity.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://qiskit.org/documentation/partners/ionq/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/Qiskit-Partners/qiskit-ionq",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit-ionq",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_ionq import IonQProvider\nprovider = IonQProvider(\"\
          MY_IONQ_TOKEN\")\nbackend = provider.get_backend(\"ionq_qpu\")\n\n# Build\
          \ circuit\nfrom qiskit.circuit.library import QuantumVolume\ncircuit = QuantumVolume(5)\n\
          \n# Transpile circuit\nfrom qiskit import transpile\ntranspiled_circuit\
          \ = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_ionq import IonQProvider\nfrom qiskit.primitives import\
          \ BackendSampler\nprovider = IonQProvider(\"MY_IONQ_TOKEN\")\nbackend =\
          \ provider.get_backend(\"ionq_qpu\")\nsampler = BackendSampler(backend)\n\
          \n# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_ionq import IonQProvider\nfrom qiskit.primitives import\
          \ BackendEstimator\nprovider = IonQProvider(\"MY_IONQ_TOKEN\")\nbackend\
          \ = provider.get_backend(\"ionq_qpu\")\nestimator = BackendEstimator(backend)\n\
          \n# Express hydrogen molecule Hamiltonian as an operator\nfrom qiskit.quantum_info\
          \ import SparsePauliOp\nH2_operator = SparsePauliOp.from_list([\n    (\"\
          II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"\
          ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"\
          XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using\
          \ VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers\
          \ import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\
          \nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"\
          cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator, ansatz, optimizer)\n\
          result = vqe.compute_minimum_eigenvalue(operator=H2_operator)\nprint(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "AQT",
    ? !!str "description"
    : !!str "AQT provides access to Calcium trapped-ion quantum devices.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://qiskit.org/documentation/partners/aqt/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/Qiskit-Partners/qiskit-aqt-provider",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit-aqt-provider",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_aqt_provider import AQTProvider\naqt = AQTProvider('MY_TOKEN')\n\
          backend = aqt.get_backend('aqt_innsbruck')\n\n# Build circuit\nfrom qiskit.circuit.library\
          \ import QuantumVolume\ncircuit = QuantumVolume(5)\n\n# Transpile circuit\n\
          from qiskit import transpile\ntranspiled_circuit = transpile(circuit, backend)\n\
          transpiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_aqt_provider import AQTProvider\nfrom qiskit.primitives\
          \ import BackendSampler\naqt = AQTProvider('MY_TOKEN')\nbackend = aqt.get_backend('aqt_innsbruck')\n\
          sampler = BackendSampler(backend)\n\n# Build circuit\nfrom qiskit import\
          \ QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\n\
          circuit.measure([0,1], [0,1])\n\n# Run the circuit and get result distribution\n\
          job = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_aqt_provider import AQTProvider\nfrom qiskit.primitives\
          \ import BackendEstimator\naqt = AQTProvider('MY_TOKEN')\nbackend = aqt.get_backend('aqt_innsbruck')\n\
          estimator = BackendEstimator(backend)\n\n# Express hydrogen molecule Hamiltonian\
          \ as an operator\nfrom qiskit.quantum_info import SparsePauliOp\nH2_operator\
          \ = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n    (\"\
          IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n    (\"\
          ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n])\n\n\
          # Calculate ground state energy using VQE\nfrom qiskit.circuit.library import\
          \ TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers\
          \ import VQE\n\nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\",\
          \ entanglement_blocks=\"cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator,\
          \ ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_operator)\n\
          print(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "NVIDIA cuStateVec",
    ? !!str "description"
    : !!str "NVIDIA cuStateVec is a high-performance library dedicated to operations\
      \ with state vectors for expressing quantum algorithms.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://docs.nvidia.com/cuda/cuquantum/custatevec/index.html",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/NVIDIA/cuQuantum",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\nconda install -c conda-forge custatevec",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from cusvaer.backends import StatevectorSimulator\nbackend = StatevectorSimulator()\n\
          \n# Build circuit\nfrom qiskit.circuit.library import QuantumVolume\ncircuit\
          \ = QuantumVolume(5)\n\n# Transpile circuit\nfrom qiskit import transpile\n\
          transpiled_circuit = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from cusvaer.backends import StatevectorSimulator\nfrom qiskit.primitives\
          \ import BackendSampler\nbackend = StatevectorSimulator()\nsampler = BackendSampler(backend)\n\
          \n# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from cusvaer.backends import StatevectorSimulator\nfrom qiskit.primitives\
          \ import BackendEstimator\nbackend = StatevectorSimulator()\nestimator =\
          \ BackendEstimator(backend)\n\n# Express hydrogen molecule Hamiltonian as\
          \ an operator\nfrom qiskit.quantum_info import SparsePauliOp\nH2_operator\
          \ = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n    (\"\
          IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n    (\"\
          ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n])\n\n\
          # Calculate ground state energy using VQE\nfrom qiskit.circuit.library import\
          \ TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers\
          \ import VQE\n\nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\",\
          \ entanglement_blocks=\"cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator,\
          \ ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_operator)\n\
          print(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "MQT DDSIM",
    ? !!str "description"
    : !!str "MQT DDSIM is a quantum circuit simulator based on decision diagrams written\
      \ in C++.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://ddsim.readthedocs.io/en/latest/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/cda-tum/ddsim",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install mqt.ddsim",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from mqt import ddsim\nprovider = ddsim.DDSIMProvider()\nbackend\
          \ = provider.get_backend('qasm_simulator')\n\n# Build circuit\nfrom qiskit.circuit.library\
          \ import QuantumVolume\ncircuit = QuantumVolume(5)\n\n# Transpile circuit\n\
          from qiskit import transpile\ntranspiled_circuit = transpile(circuit, backend)\n\
          transpiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from mqt import ddsim\nfrom qiskit.primitives import BackendSampler\n\
          provider = ddsim.DDSIMProvider()\nbackend = provider.get_backend('qasm_simulator')\n\
          sampler = BackendSampler(backend)\n\n# Build circuit\nfrom qiskit import\
          \ QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\n\
          circuit.measure([0,1], [0,1])\n\n# Run the circuit and get result distribution\n\
          job = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from mqt import ddsim\nfrom qiskit.primitives import BackendEstimator\n\
          provider = ddsim.DDSIMProvider()\nbackend = provider.get_backend('qasm_simulator')\n\
          estimator = BackendEstimator(backend)\n\n# Express hydrogen molecule Hamiltonian\
          \ as an operator\nfrom qiskit.quantum_info import SparsePauliOp\nH2_operator\
          \ = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n    (\"\
          IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n    (\"\
          ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n])\n\n\
          # Calculate ground state energy using VQE\nfrom qiskit.circuit.library import\
          \ TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers\
          \ import VQE\n\nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\",\
          \ entanglement_blocks=\"cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator,\
          \ ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_operator)\n\
          print(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "Amazon Braket",
    ? !!str "description"
    : !!str "Amazon Braket is a fully managed quantum computing service designed to\
      \ help speed up scientific research and software development for quantum computing.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://qiskit-community.github.io/qiskit-braket-provider/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/qiskit-community/qiskit-braket-provider",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit_braket_provider",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_braket_provider import AWSBraketProvider\nprovider =\
          \ AWSBraketProvider()\n\n# QuEra Aquila is a 256-qubit quantum processor\
          \ based on\n# programmable arrays of neutral Rubidium atoms\nbackend = provider.backends(\"\
          Aquila\")\n\n# Build circuit\nfrom qiskit.circuit.library import QuantumVolume\n\
          circuit = QuantumVolume(5)\n\n# Transpile circuit\nfrom qiskit import transpile\n\
          transpiled_circuit = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_braket_provider import AWSBraketProvider\nfrom qiskit.primitives\
          \ import BackendSampler\nprovider = AWSBraketProvider()\n\n# QuEra Aquila\
          \ is a 256-qubit quantum processor based on\n# programmable arrays of neutral\
          \ Rubidium atoms\nbackend = provider.backends(\"Aquila\")\nsampler = BackendSampler(backend)\n\
          \n# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_braket_provider import AWSBraketProvider\nfrom qiskit.primitives\
          \ import BackendEstimator\nprovider = AWSBraketProvider()\n\n# QuEra Aquila\
          \ is a 256-qubit quantum processor based on\n# programmable arrays of neutral\
          \ Rubidium atoms\nbackend = provider.backends(\"Aquila\")\nestimator = BackendEstimator(backend)\n\
          \n# Express hydrogen molecule Hamiltonian as an operator\nfrom qiskit.quantum_info\
          \ import SparsePauliOp\nH2_operator = SparsePauliOp.from_list([\n    (\"\
          II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"\
          ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"\
          XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using\
          \ VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers\
          \ import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\
          \nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"\
          cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator, ansatz, optimizer)\n\
          result = vqe.compute_minimum_eigenvalue(operator=H2_operator)\nprint(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "IQM",
    ? !!str "description"
    : !!str "IQM offers access to gate-model based superconducting qubits quantum\
      \ systems.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://iqm-finland.github.io/qiskit-on-iqm/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/iqm-finland/qiskit-on-iqm",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit-iqm",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_iqm import IQMProvider\nprovider = IQMProvider(iqm_server_url)\n\
          backend = provider.get_backend()\n\n# Build circuit\nfrom qiskit.circuit.library\
          \ import QuantumVolume\ncircuit = QuantumVolume(5)\n\n# Transpile circuit\n\
          from qiskit import transpile\ntranspiled_circuit = transpile(circuit, backend)\n\
          transpiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_iqm import IQMProvider\nfrom qiskit.primitives import\
          \ BackendSampler\nprovider = IQMProvider(iqm_server_url)\nbackend = provider.get_backend()\n\
          sampler = BackendSampler(backend)\n\n# Build circuit\nfrom qiskit import\
          \ QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\n\
          circuit.measure([0,1], [0,1])\n\n# Run the circuit and get result distribution\n\
          job = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_iqm import IQMProvider\nfrom qiskit.primitives import\
          \ BackendEstimator\nprovider = IQMProvider(iqm_server_url)\nbackend = provider.get_backend()\n\
          estimator = BackendEstimator(backend)\n\n# Express hydrogen molecule Hamiltonian\
          \ as an operator\nfrom qiskit.quantum_info import SparsePauliOp\nH2_operator\
          \ = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n    (\"\
          IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n    (\"\
          ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n])\n\n\
          # Calculate ground state energy using VQE\nfrom qiskit.circuit.library import\
          \ TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers\
          \ import VQE\n\nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\",\
          \ entanglement_blocks=\"cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator,\
          \ ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_operator)\n\
          print(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "Quantinuum",
    ? !!str "description"
    : !!str "Quantinuum provides access to Ytterbium trapped-ion systems with high-fidelity,\
      \ fully connected qubits, and the ability to perform mid-circuit measurement.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://github.com/qiskit-community/qiskit-quantinuum-provider/blob/master/examples/QuantinuumExample.ipynb",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/qiskit-community/qiskit-quantinuum-provider",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit-quantinuum-provider",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_quantinuum import Quantinuum\nQuantinuum.save_account(\"\
          username@company.com\")\nbackend = Quantinuum.get_backend(\"deadhead\")\n\
          \n# Build circuit\nfrom qiskit.circuit.library import QuantumVolume\ncircuit\
          \ = QuantumVolume(5)\n\n# Transpile circuit\nfrom qiskit import transpile\n\
          transpiled_circuit = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_quantinuum import Quantinuum\nfrom qiskit.primitives\
          \ import BackendSampler\nQuantinuum.save_account(\"username@company.com\"\
          )\nbackend = Quantinuum.get_backend(\"deadhead\")\nsampler = BackendSampler(backend)\n\
          \n# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_quantinuum import Quantinuum\nfrom qiskit.primitives\
          \ import BackendEstimator\nQuantinuum.save_account(\"username@company.com\"\
          )\nbackend = Quantinuum.get_backend(\"deadhead\")\nestimator = BackendEstimator(backend)\n\
          \n# Express hydrogen molecule Hamiltonian as an operator\nfrom qiskit.quantum_info\
          \ import SparsePauliOp\nH2_operator = SparsePauliOp.from_list([\n    (\"\
          II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"\
          ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"\
          XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using\
          \ VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers\
          \ import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\
          \nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"\
          cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator, ansatz, optimizer)\n\
          result = vqe.compute_minimum_eigenvalue(operator=H2_operator)\nprint(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "Rigetti",
    ? !!str "description"
    : !!str "Rigetti offers access to universal, gate-model machines based on tunable\
      \ superconducting qubits.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://qiskit-rigetti.readthedocs.io/en/latest/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/rigetti/qiskit-rigetti",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit-rigetti",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_rigetti import RigettiQCSProvider\nprovider = RigettiQCSProvider()\n\
          backend = provider.get_backend(\"Aspen-11\")\n\n# Build circuit\nfrom qiskit.circuit.library\
          \ import QuantumVolume\ncircuit = QuantumVolume(5)\n\n# Transpile circuit\n\
          from qiskit import transpile\ntranspiled_circuit = transpile(circuit, backend)\n\
          transpiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_rigetti import RigettiQCSProvider\nfrom qiskit.primitives\
          \ import BackendSampler\nprovider = RigettiQCSProvider()\nbackend = provider.get_backend(\"\
          Aspen-11\")\nsampler = BackendSampler(backend)\n\n# Build circuit\nfrom\
          \ qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\n\
          circuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n# Run the circuit and\
          \ get result distribution\njob = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\n\
          print(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_rigetti import RigettiQCSProvider\nfrom qiskit.primitives\
          \ import BackendEstimator\nprovider = RigettiQCSProvider()\nbackend = provider.get_backend(\"\
          Aspen-11\")\nestimator = BackendEstimator(backend)\n\n# Express hydrogen\
          \ molecule Hamiltonian as an operator\nfrom qiskit.quantum_info import SparsePauliOp\n\
          H2_operator = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n\
          \    (\"IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n\
          \    (\"ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n\
          ])\n\n# Calculate ground state energy using VQE\nfrom qiskit.circuit.library\
          \ import TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom\
          \ qiskit.algorithms.minimum_eigensolvers import VQE\n\nansatz = TwoLocal(num_qubits=2,\
          \ rotation_blocks=\"ry\", entanglement_blocks=\"cz\")\noptimizer = SLSQP(maxiter=100)\n\
          vqe = VQE(estimator, ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_operator)\n\
          print(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "Gaqqie",
    ? !!str "description"
    : !!str "Gaqqie is an open-source quantum computer cloud platform.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://github.com/gaqqie/gaqqie/blob/main/docs/document.pdf",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/gaqqie/gaqqie",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install gaqqie-door",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from gaqqie_door import QiskitGaqqie\n\n# rewrite to the endpoint\
          \ URL of the user API\nurl = \"https://<api-id>.execute-api.<region>.amazonaws.com/<stage>\"\
          \nQiskitGaqqie.enable_account(url)\nbackend = QiskitGaqqie.get_backend(\"\
          qiskit_simulator\")\n\n# Build circuit\nfrom qiskit.circuit.library import\
          \ QuantumVolume\ncircuit = QuantumVolume(5)\n\n# Transpile circuit\nfrom\
          \ qiskit import transpile\ntranspiled_circuit = transpile(circuit, backend)\n\
          transpiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from gaqqie_door import QiskitGaqqie\nfrom qiskit.primitives import\
          \ BackendSampler\n\n# rewrite to the endpoint URL of the user API\nurl =\
          \ \"https://<api-id>.execute-api.<region>.amazonaws.com/<stage>\"\nQiskitGaqqie.enable_account(url)\n\
          backend = QiskitGaqqie.get_backend(\"qiskit_simulator\")\nsampler = BackendSampler(backend)\n\
          \n# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from gaqqie_door import QiskitGaqqie\nfrom qiskit.primitives import\
          \ BackendEstimator\n\n# rewrite to the endpoint URL of the user API\nurl\
          \ = \"https://<api-id>.execute-api.<region>.amazonaws.com/<stage>\"\nQiskitGaqqie.enable_account(url)\n\
          backend = QiskitGaqqie.get_backend(\"qiskit_simulator\")\nestimator = BackendEstimator(backend)\n\
          \n# Express hydrogen molecule Hamiltonian as an operator\nfrom qiskit.quantum_info\
          \ import SparsePauliOp\nH2_operator = SparsePauliOp.from_list([\n    (\"\
          II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"\
          ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"\
          XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using\
          \ VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers\
          \ import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\
          \nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"\
          cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator, ansatz, optimizer)\n\
          result = vqe.compute_minimum_eigenvalue(operator=H2_operator)\nprint(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "QuaC",
    ? !!str "description"
    : !!str "QuaC is a parallel time dependent open quantum systems solver.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://github.com/0tt3r/QuaC-qiskit/tree/master/examples/demos",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/0tt3r/QuaC-qiskit",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\ngit clone https://github.com/0tt3r/QuaC-qiskit\n\
      cd QuaC-qiskit\npip install .",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from quac_qiskit import Quac\nbackend = Quac.get_backend(\"fake_vigo_density_simulator\"\
          )\n\n# Build circuit\nfrom qiskit.circuit.library import QuantumVolume\n\
          circuit = QuantumVolume(5)\n\n# Transpile circuit\nfrom qiskit import transpile\n\
          transpiled_circuit = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from quac_qiskit import Quac\nfrom qiskit.primitives import BackendSampler\n\
          backend = Quac.get_backend(\"fake_vigo_density_simulator\")\nsampler = BackendSampler(backend)\n\
          \n# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from quac_qiskit import Quac\nfrom qiskit.primitives import BackendEstimator\n\
          backend = Quac.get_backend(\"fake_vigo_density_simulator\")\nestimator =\
          \ BackendEstimator(backend)\n\n# Express hydrogen molecule Hamiltonian as\
          \ an operator\nfrom qiskit.quantum_info import SparsePauliOp\nH2_operator\
          \ = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n    (\"\
          IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n    (\"\
          ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n])\n\n\
          # Calculate ground state energy using VQE\nfrom qiskit.circuit.library import\
          \ TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers\
          \ import VQE\n\nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\",\
          \ entanglement_blocks=\"cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator,\
          \ ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_operator)\n\
          print(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "Azure Quantum",
    ? !!str "description"
    : !!str "Azure Quantum is the cloud quantum computing service of Azure, with a\
      \ diverse set of quantum solutions and technologies.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://aka.ms/AQ/Qiskit/QuickStart",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!null "null",
      ? !!str "url"
      : !!null "null",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install \"azure-quantum[qiskit]\"",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from azure.quantum.qiskit import AzureQuantumProvider\nprovider =\
          \ AzureQuantumProvider(resource_id=\"MY_RESOURCE_ID\",location=\"MY_LOCATION\"\
          )\nbackend = provider.get_backend(\"quantinuum.qpu.h1-2\")\n\n# Build circuit\n\
          from qiskit.circuit.library import QuantumVolume\ncircuit = QuantumVolume(5)\n\
          \n# Transpile circuit\nfrom qiskit import transpile\ntranspiled_circuit\
          \ = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from azure.quantum.qiskit import AzureQuantumProvider\nfrom qiskit.primitives\
          \ import BackendSampler\nprovider = AzureQuantumProvider(resource_id=\"\
          MY_RESOURCE_ID\",location=\"MY_LOCATION\")\nbackend = provider.get_backend(\"\
          quantinuum.qpu.h1-2\")\nsampler = BackendSampler(backend)\n\n# Build circuit\n\
          from qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\n\
          circuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n# Run the circuit and\
          \ get result distribution\njob = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\n\
          print(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from azure.quantum.qiskit import AzureQuantumProvider\nfrom qiskit.primitives\
          \ import BackendEstimator\nprovider = AzureQuantumProvider(resource_id=\"\
          MY_RESOURCE_ID\",location=\"MY_LOCATION\")\nbackend = provider.get_backend(\"\
          quantinuum.qpu.h1-2\")\nestimator = BackendEstimator(backend)\n\n# Express\
          \ hydrogen molecule Hamiltonian as an operator\nfrom qiskit.quantum_info\
          \ import SparsePauliOp\nH2_operator = SparsePauliOp.from_list([\n    (\"\
          II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"\
          ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"\
          XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using\
          \ VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers\
          \ import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\
          \nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"\
          cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator, ansatz, optimizer)\n\
          result = vqe.compute_minimum_eigenvalue(operator=H2_operator)\nprint(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "QC Ware Forge",
    ? !!str "description"
    : !!str "QC Ware Forge is an unique and efficient turn-key algorithms for data\
      \ scientists and powerful circuit building blocks for quantum engineers.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://github.com/qcware/qiskit_qcware/blob/master/notebooks/basic_demo.ipynb",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/qcware/qiskit_qcware",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit-qcware",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_qcware import QcwareProvider\nprovider = QcwareProvider()\n\
          backend = provider.get_backend('forge_statevector')\n\n# Build circuit\n\
          from qiskit.circuit.library import QuantumVolume\ncircuit = QuantumVolume(5)\n\
          \n# Transpile circuit\nfrom qiskit import transpile\ntranspiled_circuit\
          \ = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_qcware import QcwareProvider\nfrom qiskit.primitives\
          \ import BackendSampler\nprovider = QcwareProvider()\nbackend = provider.get_backend('forge_statevector')\n\
          sampler = BackendSampler(backend)\n\n# Build circuit\nfrom qiskit import\
          \ QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\n\
          circuit.measure([0,1], [0,1])\n\n# Run the circuit and get result distribution\n\
          job = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_qcware import QcwareProvider\nfrom qiskit.primitives\
          \ import BackendEstimator\nprovider = QcwareProvider()\nbackend = provider.get_backend('forge_statevector')\n\
          estimator = BackendEstimator(backend)\n\n# Express hydrogen molecule Hamiltonian\
          \ as an operator\nfrom qiskit.quantum_info import SparsePauliOp\nH2_operator\
          \ = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n    (\"\
          IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n    (\"\
          ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n])\n\n\
          # Calculate ground state energy using VQE\nfrom qiskit.circuit.library import\
          \ TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers\
          \ import VQE\n\nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\",\
          \ entanglement_blocks=\"cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator,\
          \ ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_operator)\n\
          print(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "Strangeworks",
    ? !!str "description"
    : !!str "Strangeworks is the ultimate collaboration of hardware, software, education,\
      \ and service providers, working to develop and test quantum and future compute\
      \ technologies.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!str "https://strangeworks.github.io/strangeworks-qiskit/",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!null "null",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install strangeworks-qiskit",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "import strangeworks\nfrom strangeworks_qiskit import StrangeworksProvider\n\
          \n# get your API key from the Strangeworks Portal\nstrangeworks.authenticate(api_key=\"\
          your-api-key\")\nprovider = StrangeworksProvider()\n\n# Xanadu Borealis\
          \ is a photonic quantum computer with a programmable loop-based\n# interferometer\
          \ with over 216 squeezed-state qubits\nbackend = provider.get_backend(\"\
          borealis\")\n\n# Build circuit\nfrom qiskit.circuit.library import QuantumVolume\n\
          circuit = QuantumVolume(5)\n\n# Transpile circuit\nfrom qiskit import transpile\n\
          transpiled_circuit = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "import strangeworks\nfrom qiskit.primitives import BackendSampler\n\
          from strangeworks_qiskit import StrangeworksProvider\n\n# get your API key\
          \ from the Strangeworks Portal\nstrangeworks.authenticate(api_key=\"your-api-key\"\
          )\nprovider = StrangeworksProvider()\n\n# Xanadu Borealis is a photonic\
          \ quantum computer with a programmable loop-based\n# interferometer with\
          \ over 216 squeezed-state qubits\nbackend = provider.get_backend(\"borealis\"\
          )\nsampler = BackendSampler(backend)\n\n# Build circuit\nfrom qiskit import\
          \ QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\n\
          circuit.measure([0,1], [0,1])\n\n# Run the circuit and get result distribution\n\
          job = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "import strangeworks\nfrom qiskit.primitives import BackendEstimator\n\
          from strangeworks_qiskit import StrangeworksProvider\n\n# get your API key\
          \ from the Strangeworks Portal\nstrangeworks.authenticate(api_key=\"your-api-key\"\
          )\nprovider = StrangeworksProvider()\n\n# Xanadu Borealis is a photonic\
          \ quantum computer with a programmable loop-based\n# interferometer with\
          \ over 216 squeezed-state qubits\nbackend = provider.get_backend(\"borealis\"\
          )\nestimator = BackendEstimator(backend)\n\n# Express hydrogen molecule\
          \ Hamiltonian as an operator\nfrom qiskit.quantum_info import SparsePauliOp\n\
          H2_operator = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n\
          \    (\"IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n\
          \    (\"ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n\
          ])\n\n# Calculate ground state energy using VQE\nfrom qiskit.circuit.library\
          \ import TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom\
          \ qiskit.algorithms.minimum_eigensolvers import VQE\n\nansatz = TwoLocal(num_qubits=2,\
          \ rotation_blocks=\"ry\", entanglement_blocks=\"cz\")\noptimizer = SLSQP(maxiter=100)\n\
          vqe = VQE(estimator, ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_operator)\n\
          print(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
  !!map {
    ? !!str "title"
    : !!str "SuperstaQ",
    ? !!str "description"
    : !!str "SuperstaQ is a hardware-agnostic software platform that connects applications\
      \ to quantum computers from IBM Quantum, IonQ, and Rigetti.",
    ? !!str "docsCta"
    : !!map {
      ? !!str "label"
      : !!str "Docs",
      ? !!str "url"
      : !!null "null",
    },
    ? !!str "sourceCta"
    : !!map {
      ? !!str "label"
      : !!str "GitHub",
      ? !!str "url"
      : !!str "https://github.com/SupertechLabs/qiskit-superstaq",
    },
    ? !!str "installation"
    : !!str "pip install qiskit\npip install qiskit-superstaq",
    ? !!str "codeExamples"
    : !!seq [
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_superstaq import SuperstaQProvider\nprovider = SuperstaQProvider(\"\
          MY_SUPERSTAQ_TOKEN\")\nbackend = provider.get_backend(\"aws_sv1_simulator\"\
          )\n\n# Build circuit\nfrom qiskit.circuit.library import QuantumVolume\n\
          circuit = QuantumVolume(5)\n\n# Transpile circuit\nfrom qiskit import transpile\n\
          transpiled_circuit = transpile(circuit, backend)\ntranspiled_circuit.draw()",
        ? !!str "name"
        : !!str "Transpile",
        ? !!str "runMethod"
        : !!str "backend",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_superstaq import SuperstaQProvider\nfrom qiskit.primitives\
          \ import BackendSampler\nprovider = SuperstaQProvider(\"MY_SUPERSTAQ_TOKEN\"\
          )\nbackend = provider.get_backend(\"aws_sv1_simulator\")\nsampler = BackendSampler(backend)\n\
          \n# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2,\
          \ 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n#\
          \ Run the circuit and get result distribution\njob = sampler.run(circuit)\n\
          quasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)",
        ? !!str "name"
        : !!str "Sample a Bell State",
        ? !!str "runMethod"
        : !!str "sampler",
      },
      !!map {
        ? !!str "fullCode"
        : !!str "from qiskit_superstaq import SuperstaQProvider\nfrom qiskit.primitives\
          \ import BackendEstimator\nprovider = SuperstaQProvider(\"MY_SUPERSTAQ_TOKEN\"\
          )\nbackend = provider.get_backend(\"aws_sv1_simulator\")\nestimator = BackendEstimator(backend)\n\
          \n# Express hydrogen molecule Hamiltonian as an operator\nfrom qiskit.quantum_info\
          \ import SparsePauliOp\nH2_operator = SparsePauliOp.from_list([\n    (\"\
          II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"\
          ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"\
          XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using\
          \ VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers\
          \ import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\
          \nansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"\
          cz\")\noptimizer = SLSQP(maxiter=100)\nvqe = VQE(estimator, ansatz, optimizer)\n\
          result = vqe.compute_minimum_eigenvalue(operator=H2_operator)\nprint(result.eigenvalue)",
        ? !!str "name"
        : !!str "Run VQE",
        ? !!str "runMethod"
        : !!str "estimator",
      },
    ],
  },
]
