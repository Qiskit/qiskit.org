[
  {
    "title": "Qiskit Stand-alone",
    "description": "Run quantum circuits and algorithms using Qiskit as a stand-alone tool with its reference implementations of simulators.",
    "installation": [
      "pip install qiskit"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://qiskit.org/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit.org/documentation/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/Qiskit/qiskit-terra"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, basis_gates=['sx', 'rz', 'cx'])",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit.primitives import Sampler",
          "sampler = Sampler()",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit.primitives import Estimator",
          "estimator = Estimator()",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "Aer",
    "description": "Aer is a high performance simulator for quantum circuits that includes noise models.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-aer"
    ],
    "websiteCta": {
      "label": null,
      "url": null
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit.org/ecosystem/aer/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/Qiskit/qiskit-aer"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_aer import AerSimulator",
          "backend = AerSimulator()",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_aer.primitives import Sampler",
          "sampler = Sampler()",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_aer.primitives import Estimator",
          "estimator = Estimator()",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "Amazon Braket",
    "description": "Amazon Braket is a fully managed quantum computing service designed to help speed up scientific research and software development for quantum computing.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit_braket_provider"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://aws.amazon.com/braket/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit-community.github.io/qiskit-braket-provider/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/qiskit-community/qiskit-braket-provider"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_braket_provider import AWSBraketProvider",
          "provider = AWSBraketProvider()",
          "# QuEra Aquila is a 256-qubit quantum processor based on",
          "# programmable arrays of neutral Rubidium atoms",
          "backend = provider.backends(\"Aquila\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_braket_provider import AWSBraketProvider",
          "from qiskit.primitives import BackendSampler",
          "provider = AWSBraketProvider()",
          "# QuEra Aquila is a 256-qubit quantum processor based on",
          "# programmable arrays of neutral Rubidium atoms",
          "backend = provider.backends(\"Aquila\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_braket_provider import AWSBraketProvider",
          "from qiskit.primitives import BackendEstimator",
          "provider = AWSBraketProvider()",
          "# QuEra Aquila is a 256-qubit quantum processor based on",
          "# programmable arrays of neutral Rubidium atoms",
          "backend = provider.backends(\"Aquila\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "AQT",
    "description": "AQT provides access to Calcium trapped-ion quantum devices.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-aqt-provider"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://www.aqt.eu/qc-systems/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit.org/documentation/partners/aqt/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/Qiskit-Partners/qiskit-aqt-provider"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_aqt_provider import AQTProvider",
          "aqt = AQTProvider('MY_TOKEN')",
          "backend = aqt.get_backend('aqt_innsbruck')",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_aqt_provider import AQTProvider",
          "from qiskit.primitives import BackendSampler",
          "aqt = AQTProvider('MY_TOKEN')",
          "backend = aqt.get_backend('aqt_innsbruck')",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_aqt_provider import AQTProvider",
          "from qiskit.primitives import BackendEstimator",
          "aqt = AQTProvider('MY_TOKEN')",
          "backend = aqt.get_backend('aqt_innsbruck')",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "Azure Quantum",
    "description": "Azure Quantum is the cloud quantum computing service of Azure, with a diverse set of quantum solutions and technologies.",
    "installation": [
      "pip install qiskit",
      "pip install \"azure-quantum[qiskit]\""
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://aka.ms/aq"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://aka.ms/AQ/Qiskit/QuickStart"
    },
    "sourceCta": {
      "label": null,
      "url": null
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from azure.quantum.qiskit import AzureQuantumProvider",
          "provider = AzureQuantumProvider(resource_id=\"MY_RESOURCE_ID\",location=\"MY_LOCATION\")",
          "backend = provider.get_backend(\"quantinuum.qpu.h1-2\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from azure.quantum.qiskit import AzureQuantumProvider",
          "from qiskit.primitives import BackendSampler",
          "provider = AzureQuantumProvider(resource_id=\"MY_RESOURCE_ID\",location=\"MY_LOCATION\")",
          "backend = provider.get_backend(\"quantinuum.qpu.h1-2\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from azure.quantum.qiskit import AzureQuantumProvider",
          "from qiskit.primitives import BackendEstimator",
          "provider = AzureQuantumProvider(resource_id=\"MY_RESOURCE_ID\",location=\"MY_LOCATION\")",
          "backend = provider.get_backend(\"quantinuum.qpu.h1-2\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "Gaqqie",
    "description": "Gaqqie is an open-source quantum computer cloud platform.",
    "installation": [
      "pip install qiskit",
      "pip install gaqqie-door"
    ],
    "websiteCta": {
      "label": "Website",
      "url": null
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://github.com/gaqqie/gaqqie/blob/main/docs/document.pdf"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/gaqqie/gaqqie"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from gaqqie_door import QiskitGaqqie",
          "# rewrite to the endpoint URL of the user API",
          "url = \"https://<api-id>.execute-api.<region>.amazonaws.com/<stage>\"",
          "QiskitGaqqie.enable_account(url)",
          "backend = QiskitGaqqie.get_backend(\"qiskit_simulator\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from gaqqie_door import QiskitGaqqie",
          "from qiskit.primitives import BackendSampler",
          "# rewrite to the endpoint URL of the user API",
          "url = \"https://<api-id>.execute-api.<region>.amazonaws.com/<stage>\"",
          "QiskitGaqqie.enable_account(url)",
          "backend = QiskitGaqqie.get_backend(\"qiskit_simulator\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from gaqqie_door import QiskitGaqqie",
          "from qiskit.primitives import BackendEstimator",
          "# rewrite to the endpoint URL of the user API",
          "url = \"https://<api-id>.execute-api.<region>.amazonaws.com/<stage>\"",
          "QiskitGaqqie.enable_account(url)",
          "backend = QiskitGaqqie.get_backend(\"qiskit_simulator\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "IBM Qiskit Runtime",
    "description": "Qiskit Runtime is a quantum computing service and programming model that allows users to optimize workloads and efficiently execute them on quantum systems at scale. The programming model extends the existing interface in Qiskit with a set of new primitive programs.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-ibm-runtime"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://quantum-computing.ibm.com/lab/docs/iql/runtime/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit.org/documentation/partners/qiskit_ibm_runtime/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/Qiskit/qiskit-ibm-runtime"
    },
    "codeExamples": [
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_ibm_runtime import QiskitRuntimeService, Sampler",
          "service = QiskitRuntimeService()",
          "backend = service.backend(\"ibm_perth\")",
          "sampler = Sampler(session=backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_ibm_runtime import QiskitRuntimeService, Estimator",
          "service = QiskitRuntimeService()",
          "backend = service.backend(\"ibm_perth\")",
          "estimator = Estimator(session=backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "IBM Quantum",
    "description": "IBM Quantum offers both open and premium access to a wide variety of quantum systems. All quantum systems deployed by IBM Quantum are based on superconducting qubit technology, as the control and scalability of this technology pave a clear path to achieving quantum advantage with these systems.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-ibm-provider"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://quantum-computing.ibm.com/services?services=systems"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit.org/documentation/partners/qiskit_ibm_provider/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/Qiskit/qiskit-ibm-provider"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_ibm_provider import IBMProvider",
          "IBMProvider.save_account(\"MY_IBM_QUANTUM_TOKEN\")",
          "provider = IBMProvider()",
          "backend = provider.get_backend(\"ibm_nairobi\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_ibm_provider import IBMProvider",
          "from qiskit.primitives import BackendSampler",
          "IBMProvider.save_account(\"MY_IBM_QUANTUM_TOKEN\")",
          "provider = IBMProvider()",
          "backend = provider.get_backend(\"ibm_nairobi\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_ibm_provider import IBMProvider",
          "from qiskit.primitives import BackendEstimator",
          "IBMProvider.save_account(\"MY_IBM_QUANTUM_TOKEN\")",
          "provider = IBMProvider()",
          "backend = provider.get_backend(\"ibm_nairobi\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "IonQ",
    "description": "IonQ offers access to Ytterbium trapped-ion quantum computers with high gate fidelity, long coherence time and all-to-all connectivity.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-ionq"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://ionq.com/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit.org/documentation/partners/ionq/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/Qiskit-Partners/qiskit-ionq"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_ionq import IonQProvider",
          "provider = IonQProvider(\"MY_IONQ_TOKEN\")",
          "backend = provider.get_backend(\"ionq_qpu\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_ionq import IonQProvider",
          "from qiskit.primitives import BackendSampler",
          "provider = IonQProvider(\"MY_IONQ_TOKEN\")",
          "backend = provider.get_backend(\"ionq_qpu\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_ionq import IonQProvider",
          "from qiskit.primitives import BackendEstimator",
          "provider = IonQProvider(\"MY_IONQ_TOKEN\")",
          "backend = provider.get_backend(\"ionq_qpu\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "IQM",
    "description": "IQM offers access to gate-model based superconducting qubits quantum systems.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-iqm"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://www.meetiqm.com/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://iqm-finland.github.io/qiskit-on-iqm/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/iqm-finland/qiskit-on-iqm"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_iqm import IQMProvider",
          "provider = IQMProvider(iqm_server_url)",
          "backend = provider.get_backend()",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_iqm import IQMProvider",
          "from qiskit.primitives import BackendSampler",
          "provider = IQMProvider(iqm_server_url)",
          "backend = provider.get_backend()",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_iqm import IQMProvider",
          "from qiskit.primitives import BackendEstimator",
          "provider = IQMProvider(iqm_server_url)",
          "backend = provider.get_backend()",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "MQT DDSIM",
    "description": "MQT DDSIM is a quantum circuit simulator based on decision diagrams written in C++.",
    "installation": [
      "pip install qiskit",
      "pip install mqt.ddsim"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://www.cda.cit.tum.de/research/quantum_simulation/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://ddsim.readthedocs.io/en/latest/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/cda-tum/ddsim"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from mqt import ddsim",
          "provider = ddsim.DDSIMProvider()",
          "backend = provider.get_backend('qasm_simulator')",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from mqt import ddsim",
          "from qiskit.primitives import BackendSampler",
          "provider = ddsim.DDSIMProvider()",
          "backend = provider.get_backend('qasm_simulator')",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from mqt import ddsim",
          "from qiskit.primitives import BackendEstimator",
          "provider = ddsim.DDSIMProvider()",
          "backend = provider.get_backend('qasm_simulator')",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "NVIDIA cuStateVec",
    "description": "NVIDIA cuStateVec is a high-performance library dedicated to operations with state vectors for expressing quantum algorithms.",
    "installation": [
      "pip install qiskit",
      "conda install -c conda-forge custatevec"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://developer.nvidia.com/cuquantum-sdk"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://docs.nvidia.com/cuda/cuquantum/custatevec/index.html"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/NVIDIA/cuQuantum"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from cusvaer.backends import StatevectorSimulator",
          "backend = StatevectorSimulator()",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from cusvaer.backends import StatevectorSimulator",
          "from qiskit.primitives import BackendSampler",
          "backend = StatevectorSimulator()",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from cusvaer.backends import StatevectorSimulator",
          "from qiskit.primitives import BackendEstimator",
          "backend = StatevectorSimulator()",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "QC Ware Forge",
    "description": "QC Ware Forge is an unique and efficient turn-key algorithms for data scientists and powerful circuit building blocks for quantum engineers.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-qcware"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://forge.qcware.com/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://github.com/qcware/qiskit_qcware/blob/master/notebooks/basic_demo.ipynb"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/qcware/qiskit_qcware"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_qcware import QcwareProvider",
          "provider = QcwareProvider()",
          "backend = provider.get_backend('forge_statevector')",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_qcware import QcwareProvider",
          "from qiskit.primitives import BackendSampler",
          "provider = QcwareProvider()",
          "backend = provider.get_backend('forge_statevector')",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_qcware import QcwareProvider",
          "from qiskit.primitives import BackendEstimator",
          "provider = QcwareProvider()",
          "backend = provider.get_backend('forge_statevector')",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "QuaC",
    "description": "QuaC is a parallel time dependent open quantum systems solver.",
    "installation": [
      "pip install qiskit",
      "git clone https://github.com/0tt3r/QuaC-qiskit\ncd QuaC-qiskit\npip install ."
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://0tt3r.github.io/QuaC/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://github.com/0tt3r/QuaC-qiskit/tree/master/examples/demos"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/0tt3r/QuaC-qiskit"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from quac_qiskit import Quac",
          "backend = Quac.get_backend(\"fake_vigo_density_simulator\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from quac_qiskit import Quac",
          "from qiskit.primitives import BackendSampler",
          "backend = Quac.get_backend(\"fake_vigo_density_simulator\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from quac_qiskit import Quac",
          "from qiskit.primitives import BackendEstimator",
          "backend = Quac.get_backend(\"fake_vigo_density_simulator\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "Quantinuum",
    "description": "Quantinuum provides access to Ytterbium trapped-ion systems with high-fidelity, fully connected qubits, and the ability to perform mid-circuit measurement.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-quantinuum-provider"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://www.quantinuum.com/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://github.com/qiskit-community/qiskit-quantinuum-provider/blob/master/examples/QuantinuumExample.ipynb"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/qiskit-community/qiskit-quantinuum-provider"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_quantinuum import Quantinuum",
          "Quantinuum.save_account(\"username@company.com\")",
          "backend = Quantinuum.get_backend(\"deadhead\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_quantinuum import Quantinuum",
          "from qiskit.primitives import BackendSampler",
          "Quantinuum.save_account(\"username@company.com\")",
          "backend = Quantinuum.get_backend(\"deadhead\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_quantinuum import Quantinuum",
          "from qiskit.primitives import BackendEstimator",
          "Quantinuum.save_account(\"username@company.com\")",
          "backend = Quantinuum.get_backend(\"deadhead\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "Rigetti",
    "description": "Rigetti offers access to universal, gate-model machines based on tunable superconducting qubits.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-rigetti"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://www.rigetti.com/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit-rigetti.readthedocs.io/en/latest/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/rigetti/qiskit-rigetti"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_rigetti import RigettiQCSProvider",
          "provider = RigettiQCSProvider()",
          "backend = provider.get_backend(\"Aspen-11\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_rigetti import RigettiQCSProvider",
          "from qiskit.primitives import BackendSampler",
          "provider = RigettiQCSProvider()",
          "backend = provider.get_backend(\"Aspen-11\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_rigetti import RigettiQCSProvider",
          "from qiskit.primitives import BackendEstimator",
          "provider = RigettiQCSProvider()",
          "backend = provider.get_backend(\"Aspen-11\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "Rigetti Quantum Virtual Machine (QVM)",
    "description": "The Rigetti Quantum Virtual Machine is a wavefunction simulation of unitary evolution with classical control flow and shared quantum classical memory.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-rigetti"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://www.rigetti.com/applications/qvm"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit-rigetti.readthedocs.io/en/latest/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/rigetti/qiskit-rigetti"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_rigetti import RigettiQCSProvider",
          "provider = RigettiQCSProvider()",
          "backend = provider.get_simulator(num_qubits=5, noisy=True)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_rigetti import RigettiQCSProvider",
          "from qiskit.primitives import BackendSampler",
          "provider = RigettiQCSProvider()",
          "backend = provider.get_simulator(num_qubits=5, noisy=True)",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_rigetti import RigettiQCSProvider",
          "from qiskit.primitives import BackendEstimator",
          "provider = RigettiQCSProvider()",
          "backend = provider.get_simulator(num_qubits=5, noisy=True)",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "Strangeworks",
    "description": "Strangeworks is the ultimate collaboration of hardware, software, education, and service providers, working to develop and test quantum and future compute technologies.",
    "installation": [
      "pip install qiskit",
      "pip install strangeworks-qiskit"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://strangeworks.com/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://strangeworks.github.io/strangeworks-qiskit/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": null
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "import strangeworks",
          "from strangeworks_qiskit import StrangeworksProvider",
          "# get your API key from the Strangeworks Portal",
          "strangeworks.authenticate(api_key=\"your-api-key\")",
          "provider = StrangeworksProvider()",
          "# Xanadu Borealis is a photonic quantum computer with a programmable loop-based",
          "# interferometer with over 216 squeezed-state qubits",
          "backend = provider.get_backend(\"borealis\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "import strangeworks",
          "from qiskit.primitives import BackendSampler",
          "from strangeworks_qiskit import StrangeworksProvider",
          "# get your API key from the Strangeworks Portal",
          "strangeworks.authenticate(api_key=\"your-api-key\")",
          "provider = StrangeworksProvider()",
          "# Xanadu Borealis is a photonic quantum computer with a programmable loop-based",
          "# interferometer with over 216 squeezed-state qubits",
          "backend = provider.get_backend(\"borealis\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "import strangeworks",
          "from qiskit.primitives import BackendEstimator",
          "from strangeworks_qiskit import StrangeworksProvider",
          "# get your API key from the Strangeworks Portal",
          "strangeworks.authenticate(api_key=\"your-api-key\")",
          "provider = StrangeworksProvider()",
          "# Xanadu Borealis is a photonic quantum computer with a programmable loop-based",
          "# interferometer with over 216 squeezed-state qubits",
          "backend = provider.get_backend(\"borealis\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "SuperstaQ",
    "description": "SuperstaQ is a hardware-agnostic software platform that connects applications to quantum computers from IBM Quantum, IonQ, and Rigetti.",
    "installation": [
      "pip install qiskit",
      "pip install qiskit-superstaq"
    ],
    "websiteCta": {
      "label": "Website",
      "url": "https://www.super.tech/about-superstaq/"
    },
    "docsCta": {
      "label": "Docs",
      "url": null
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/SupertechLabs/qiskit-superstaq"
    },
    "codeExamples": [
      {
        "name": "Transpiling",
        "runMethod": "backend",
        "fullCode": [
          "from qiskit_superstaq import SuperstaQProvider",
          "provider = SuperstaQProvider(\"MY_SUPERSTAQ_TOKEN\")",
          "backend = provider.get_backend(\"aws_sv1_simulator\")",
          "&nbsp;",
          "# Build circuit",
          "from qiskit.circuit.library import QuantumVolume",
          "circuit = QuantumVolume(5)",
          "&nbsp;",
          "# Transpile circuit",
          "from qiskit import transpile",
          "transpiled_circuit = transpile(circuit, backend)",
          "transpiled_circuit.draw()"
        ]
      },
      {
        "name": "Sampling Bell Circuit",
        "runMethod": "sampler",
        "fullCode": [
          "from qiskit_superstaq import SuperstaQProvider",
          "from qiskit.primitives import BackendSampler",
          "provider = SuperstaQProvider(\"MY_SUPERSTAQ_TOKEN\")",
          "backend = provider.get_backend(\"aws_sv1_simulator\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "Running VQE",
        "runMethod": "estimator",
        "fullCode": [
          "from qiskit_superstaq import SuperstaQProvider",
          "from qiskit.primitives import BackendEstimator",
          "provider = SuperstaQProvider(\"MY_SUPERSTAQ_TOKEN\")",
          "backend = provider.get_backend(\"aws_sv1_simulator\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "# Express hydrogen molecule Hamiltonian as an operator",
          "from qiskit.quantum_info import SparsePauliOp",
          "H2_operator = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(num_qubits=2, rotation_blocks=\"ry\", entanglement_blocks=\"cz\")",
          "optimizer = SLSQP(maxiter=100)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_operator)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  }
]